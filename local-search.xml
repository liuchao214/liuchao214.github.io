<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue最全知识点，面试必备</title>
    <link href="/2020/09/24/vue/Vue%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
    <url>/2020/09/24/vue/Vue%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本篇文章纯属笔记性文章，非整体原创，是对vue知识的整理，对自己有很大帮助才分享出来，参考文章传送:1.童欧巴对vue知识的整理 2.我是你的超级英雄对vue知识的整理 3.vue官网</p></blockquote><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="说说你对MVVM的理解"><a href="#说说你对MVVM的理解" class="headerlink" title="说说你对MVVM的理解"></a>说说你对MVVM的理解</h3><ul><li>Model-View-ViewModel的缩写，Model代表数据模型，View代表UI组件,ViewModel将Model和View关联起来</li><li>数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据</li></ul><blockquote><p><a href="https://juejin.im/post/6844904115324223495">了解mvc/mvp/mvvm的区别</a></p></blockquote><h2 id="Vue2-x响应式数据-双向绑定原理"><a href="#Vue2-x响应式数据-双向绑定原理" class="headerlink" title="Vue2.x响应式数据/双向绑定原理"></a>Vue2.x响应式数据/双向绑定原理</h2><ul><li>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。</li><li>简述：<ul><li>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。</li><li>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。</li><li>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</li></ul></li></ul><p><img src="/images/pages/virtual-dom.png" alt="virtual-dom"></p><h3 id="深入理解："><a href="#深入理解：" class="headerlink" title="深入理解："></a>深入理解：</h3><ul><li>监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li><li>解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li><li>订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式</li><li>订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter</title>
    <link href="/2018/06/01/vue/VueRouter/"/>
    <url>/2018/06/01/vue/VueRouter/</url>
    
    <content type="html"><![CDATA[<h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><ul><li>hash</li><li>history</li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>带＃</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>需要server支持</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> User = &#123;    template:<span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;&#x27;</span>&#125;<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;    routes:[        <span class="hljs-comment">// 动态路径参数 以冒号开头。命中/user/10等格式路由</span>        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/user/:id&#x27;</span>,<span class="hljs-attr">component</span>:User&#125;    ]&#125;)</code></pre><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>Vue.use(VueRouter)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123; routes: [ &#123; path: <span class="hljs-string">&#x27;/&#x27;</span>, name: <span class="hljs-string">&#x27;Navigator&#x27;</span>, component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;navigator&quot; */</span> <span class="hljs-string">&#x27;./../components/Navigator&#x27;</span>) &#125;, &#123; path: <span class="hljs-string">&#x27;/tucao&#x27;</span>, name: <span class="hljs-string">&#x27;Tucao&#x27;</span>, component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;tucao&quot; */</span> <span class="hljs-string">&#x27;./../components/Tucao&#x27;</span>) &#125; ]&#125;)</code></pre><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>路由钩子函数有三种：</p><ol><li><p>全局钩子： beforeEach、 afterEach</p></li><li><p>单个路由里面的钩子： beforeEnter、 beforeLeave</p></li><li><p>组件路由：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave</p></li></ol><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>无论访问哪一个路径，都会触发全局的钩子函数，位置是调用router的方法</p><p><strong>router.beforeEach() 进入之前触发</strong></p><p><strong>router.afterEach() 进入之后触发</strong></p><h4 id="beforeEach（全局前置守卫）"><a href="#beforeEach（全局前置守卫）" class="headerlink" title="beforeEach（全局前置守卫）"></a>beforeEach（全局前置守卫）</h4><p>使用 router.beforeEach 注册一个全局前置守卫</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;    ...&#125;)router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>) =&gt;</span> &#123;    <span class="hljs-comment">// do something....   </span>&#125;)</code></pre><p>每个守卫方法接收三个参数：</p><ul><li>to: Route: 即将要进入的目标路由对象（to是一个对象，是将要进入的路由对象，可以用to.path调用路由对象中的属性）</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 这是一个必须需要调用的方法，执行效果依赖 next 方法的调用参数。</li></ul><h5 id="next参数"><a href="#next参数" class="headerlink" title="next参数"></a>next参数</h5><ul><li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed (确认的)。</li><li>next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按 钮)，那么 URL 地址会重置到 from 路由对应的地址。</li><li>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在router-link 的 to prop或router.push中的选项。</li><li>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给router.onError()注册过的回调。</li></ul><blockquote><p>确保要调用 next 方法，否则钩子就不会被 resolved。</p></blockquote><h4 id="afterEach（全局后置钩子）"><a href="#afterEach（全局后置钩子）" class="headerlink" title="afterEach（全局后置钩子）"></a>afterEach（全局后置钩子）</h4><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;    ...&#125;)router.afterEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span></span>)=&gt;</span>&#123;    <span class="hljs-comment">// do something....   </span>&#125;)</code></pre><p>和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身</p><h4 id="路由独享的守卫-单个路由独享的"><a href="#路由独享的守卫-单个路由独享的" class="headerlink" title="路由独享的守卫(单个路由独享的)"></a>路由独享的守卫(单个路由独享的)</h4><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123;    routes: [        &#123;            path: <span class="hljs-string">&#x27;/&#x27;</span>,            name: <span class="hljs-string">&#x27;Navigator&#x27;</span>,            beforeEnter:(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;                <span class="hljs-comment">// do something....   </span>            &#125;),            component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;navigator&quot; */</span> <span class="hljs-string">&#x27;./../components/Navigator&#x27;</span>)        &#125;    ]&#125;)</code></pre><h4 id="组件级路由钩子"><a href="#组件级路由钩子" class="headerlink" title="组件级路由钩子"></a>组件级路由钩子</h4><pre><code class="hljs stylus">&#123;data,methods<span class="hljs-function"><span class="hljs-title">beforeRouteEnter</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">// this 不指向实例 组件还没创建</span>    next((vm) =&gt;&#123;        <span class="hljs-comment">// vm就是实例</span>    &#125;)&#125;<span class="hljs-function"><span class="hljs-title">beforeRouteUpdate</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// do something....   </span>&#125;<span class="hljs-function"><span class="hljs-title">beforeRouteLeave</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// do something....   </span>&#125; &#125;</code></pre><p><img src="luyou1.png" alt="image"><br>beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p><p><img src="luyou2.png" alt="image"></p><p>注意~ ： beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</p><p>这个离开守卫beforeRouteLeave()通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</p><p><img src="luyou3.png" alt="image"></p><h4 id="完整的导航解析流程："><a href="#完整的导航解析流程：" class="headerlink" title="完整的导航解析流程："></a>完整的导航解析流程：</h4><ol><li><p>导航被触发。</p></li><li><p>在失活的组件里调用离开守卫。</p></li><li><p>调用全局的 beforeEach 守卫。</p></li><li><p>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</p></li><li><p>在路由配置里调用 beforeEnter。</p></li><li><p>解析异步路由组件。</p></li><li><p>在被激活的组件里调用 beforeRouteEnter。</p></li><li><p>调用全局的 beforeResolve 守卫 (2.5+)。</p></li><li><p>导航被确认。</p></li><li><p>调用全局的 afterEach 钩子。</p></li><li><p>触发 DOM 更新。</p></li><li><p>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件渲染过程</title>
    <link href="/2018/03/11/vue/Vue%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    <url>/2018/03/11/vue/Vue%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="初次渲染过程"><a href="#初次渲染过程" class="headerlink" title="初次渲染过程"></a>初次渲染过程</h2><ol><li>解析模版为render函数（编译打包时已经完成，开发环境下完成）（vue-loader）</li><li>触发响应式，监听data属性，getter setter</li><li>执行render函数，生成vnode，patch（elem,vnode）</li></ol><h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><ol><li>修改data，触发setter（此前在getter中已经被监听）</li><li>重新执行render函数，生成newVnode</li><li>patch(vnode,newVnode)</li></ol><h2 id="异步渲染过程"><a href="#异步渲染过程" class="headerlink" title="异步渲染过程"></a>异步渲染过程</h2><ol><li>$nextTick</li><li>汇总data的修改一次性更新视图</li><li>修改DOM操作次数，提升性能</li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue模板编译</title>
    <link href="/2018/02/28/vue/Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/"/>
    <url>/2018/02/28/vue/Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h3 id="模版编译"><a href="#模版编译" class="headerlink" title="模版编译"></a>模版编译</h3><ul><li>模版是vue开发中最常用的部分，即与使用相关的原理</li><li>不是html，有指令等</li><li>组件渲染和更新的过程</li></ul><h3 id="js的with语法"><a href="#js的with语法" class="headerlink" title="js的with语法"></a>js的with语法</h3><ul><li>改变{}内自由变量的查找规则，当作obj的属性来查找</li><li>如果找不到匹配的属性，则报错</li><li>with慎用，打破了作用域的规则，易读性差</li></ul><h3 id="vue-template-complier将模版编译为render函数"><a href="#vue-template-complier将模版编译为render函数" class="headerlink" title="vue template complier将模版编译为render函数"></a>vue template complier将模版编译为render函数</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> compiler = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-template-compiler&#x27;</span>)<span class="hljs-comment">// 插值</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;`</span><span class="hljs-comment">// with(this)&#123;return createElement(&#x27;p&#x27;,[createTextVNode(toString(message))])&#125;</span><span class="hljs-comment">// h -&gt; vnode</span><span class="hljs-comment">// createElement -&gt; vnode</span><span class="hljs-comment">// // 表达式</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`&lt;p&gt;&#123;&#123;flag ? message : &#x27;no message found&#x27;&#125;&#125;&lt;/p&gt;`</span><span class="hljs-comment">// // with(this)&#123;return _c(&#x27;p&#x27;,[_v(_s(flag ? message : &#x27;no message found&#x27;))])&#125;</span><span class="hljs-comment">// // 属性和动态属性</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><span class="hljs-string">    &lt;div id=&quot;div1&quot; class=&quot;container&quot;&gt;</span><span class="hljs-string">        &lt;img :src=&quot;imgUrl&quot;/&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">`</span><span class="hljs-comment">// with(this)&#123;return _c(&#x27;div&#x27;,</span><span class="hljs-comment">//      &#123;staticClass:&quot;container&quot;,attrs:&#123;&quot;id&quot;:&quot;div1&quot;&#125;&#125;,</span><span class="hljs-comment">//      [</span><span class="hljs-comment">//          _c(&#x27;img&#x27;,&#123;attrs:&#123;&quot;src&quot;:imgUrl&#125;&#125;)])&#125;</span><span class="hljs-comment">// // 条件</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><span class="hljs-string">    &lt;div&gt;</span><span class="hljs-string">        &lt;p v-if=&quot;flag === &#x27;a&#x27;&quot;&gt;A&lt;/p&gt;</span><span class="hljs-string">        &lt;p v-else-if=&quot;flag === &#x27;b&#x27;&quot;&gt;C&lt;/p&gt;</span><span class="hljs-string">        &lt;p v-else&gt;B&lt;/p&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">`</span><span class="hljs-comment">// with(this)&#123;return _c(&#x27;div&#x27;,[(flag === &#x27;a&#x27;)?_c(&#x27;p&#x27;,[_v(&quot;A&quot;)]):_c(&#x27;p&#x27;,[_v(&quot;B&quot;)])])&#125;</span><span class="hljs-comment">// 循环</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><span class="hljs-string">    &lt;ul&gt;</span><span class="hljs-string">        &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/li&gt;</span><span class="hljs-string">    &lt;/ul&gt;</span><span class="hljs-string">`</span><span class="hljs-comment">// with(this)&#123;return _c(&#x27;ul&#x27;,_l((list),function(item)&#123;return _c(&#x27;li&#x27;,&#123;key:item.id&#125;,[_v(_s(item.title))])&#125;),0)&#125;</span><span class="hljs-comment">// 事件</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><span class="hljs-string">    &lt;button @click=&quot;clickHandler&quot;&gt;submit&lt;/button&gt;</span><span class="hljs-string">`</span><span class="hljs-comment">// with(this)&#123;return _c(&#x27;button&#x27;,&#123;on:&#123;&quot;click&quot;:clickHandler&#125;&#125;,[_v(&quot;submit&quot;)])&#125;</span><span class="hljs-comment">// v-model</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;`</span><span class="hljs-comment">// 主要看 input 事件</span><span class="hljs-comment">// with(this)&#123;return _c(&#x27;input&#x27;,&#123;directives:[&#123;name:&quot;model&quot;,rawName:&quot;v-model&quot;,value:(name),expression:&quot;name&quot;&#125;],attrs:&#123;&quot;type&quot;:&quot;text&quot;&#125;,domProps:&#123;&quot;value&quot;:(name)&#125;,on:&#123;&quot;input&quot;:function($event)&#123;if($event.target.composing)return;name=$event.target.value&#125;&#125;&#125;)&#125;</span><span class="hljs-comment">// render 函数</span><span class="hljs-comment">// 返回 vnode</span><span class="hljs-comment">// patch</span><span class="hljs-comment">// 编译</span><span class="hljs-keyword">const</span> res = compiler.compile(template)<span class="hljs-built_in">console</span>.log(res.render)<span class="hljs-comment">// ---------------分割线--------------</span><span class="hljs-comment">// // 从 vue 源码中找到缩写函数的含义</span><span class="hljs-comment">// function installRenderHelpers (target) &#123;</span><span class="hljs-comment">//     target._o = markOnce;</span><span class="hljs-comment">//     target._n = toNumber;</span><span class="hljs-comment">//     target._s = toString;</span><span class="hljs-comment">//     target._l = renderList;</span><span class="hljs-comment">//     target._t = renderSlot;</span><span class="hljs-comment">//     target._q = looseEqual;</span><span class="hljs-comment">//     target._i = looseIndexOf;</span><span class="hljs-comment">//     target._m = renderStatic;</span><span class="hljs-comment">//     target._f = resolveFilter;</span><span class="hljs-comment">//     target._k = checkKeyCodes;</span><span class="hljs-comment">//     target._b = bindObjectProps;</span><span class="hljs-comment">//     target._v = createTextVNode;</span><span class="hljs-comment">//     target._e = createEmptyVNode;</span><span class="hljs-comment">//     target._u = resolveScopedSlots;</span><span class="hljs-comment">//     target._g = bindObjectListeners;</span><span class="hljs-comment">//     target._d = bindDynamicKeys;</span><span class="hljs-comment">//     target._p = prependModifier;</span><span class="hljs-comment">// &#125;</span></code></pre><h3 id="执行render-生成-vnode"><a href="#执行render-生成-vnode" class="headerlink" title="执行render 生成 vnode"></a>执行render 生成 vnode</h3><p>执行render函数生成vnode</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>模版编译为render函数，执行render函数返回vnode</li><li>基于vonde再执行patch和diff</li><li>使用webpack vue-loader，会在开发环境下编译模版</li><li>可以使用render代替template</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的数据劫持</title>
    <link href="/2018/02/16/vue/Vue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81/"/>
    <url>/2018/02/16/vue/Vue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<h3 id="Object-defineProperty-obj-prop-desc"><a href="#Object-defineProperty-obj-prop-desc" class="headerlink" title="Object.defineProperty(obj, prop, desc)"></a>Object.defineProperty(obj, prop, desc)</h3><p><strong>核心的API</strong></p><h3 id="监听对象（简单）"><a href="#监听对象（简单）" class="headerlink" title="监听对象（简单）"></a>监听对象（简单）</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;&#125;<span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;zhangsan&#x27;</span><span class="hljs-built_in">Object</span>.defineProperty(data, <span class="hljs-string">&#x27;name&#x27;</span> ,&#123;    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;get &#x27;</span>+name)        <span class="hljs-keyword">return</span> name    &#125;,    set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;set &#x27;</span>+value)        name = value     &#125;&#125;)</code></pre><h3 id="复杂对象监听"><a href="#复杂对象监听" class="headerlink" title="复杂对象监听"></a>复杂对象监听</h3><h4 id="线程上的代码"><a href="#线程上的代码" class="headerlink" title="线程上的代码"></a>线程上的代码</h4><pre><code class="hljs js"><span class="hljs-comment">// 准备数据</span><span class="hljs-keyword">const</span> data = &#123;    name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,    age: <span class="hljs-number">20</span>,    info: &#123;        address: <span class="hljs-string">&#x27;北京&#x27;</span> <span class="hljs-comment">// 需要深度监听</span>    &#125;,    nums: [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]&#125;<span class="hljs-comment">// 监听数据</span>observer(data)<span class="hljs-comment">// 测试</span>data.name = <span class="hljs-string">&#x27;lisi&#x27;</span>data.age = <span class="hljs-number">21</span></code></pre><h4 id="observer方法"><a href="#observer方法" class="headerlink" title="observer方法"></a>observer方法</h4><pre><code class="hljs js"><span class="hljs-comment">// 监听对象属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observer</span>(<span class="hljs-params">target</span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target === <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 不是对象或数组</span>        <span class="hljs-keyword">return</span> target    &#125;    <span class="hljs-comment">// 重新定义各个属性（for in 也可以遍历数组）</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> target) &#123;        defineReactive(target, key, target[key])    &#125;&#125;</code></pre><h4 id="defineReactive方法"><a href="#defineReactive方法" class="headerlink" title="defineReactive方法"></a>defineReactive方法</h4><pre><code class="hljs js"><span class="hljs-comment">// 重新定义属性，监听起来</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">target, key, value</span>) </span>&#123;    <span class="hljs-comment">// 深度监听</span>    observer(value)    <span class="hljs-comment">// 核心 API</span>    <span class="hljs-built_in">Object</span>.defineProperty(target, key, &#123;        get() &#123;            <span class="hljs-keyword">return</span> value        &#125;,        set(newValue) &#123;            <span class="hljs-keyword">if</span> (newValue !== value) &#123;                <span class="hljs-comment">// 深度监听</span>                observer(newValue)                <span class="hljs-comment">// 设置新值</span>                <span class="hljs-comment">// 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值</span>                value = newValue                <span class="hljs-comment">// 触发更新视图</span>                updateView()            &#125;        &#125;    &#125;)&#125;</code></pre><blockquote><p>此处使用递归的形式，进行对象的向下遍历</p></blockquote><h4 id="Object-defineProperty的缺点"><a href="#Object-defineProperty的缺点" class="headerlink" title="Object.defineProperty的缺点"></a>Object.defineProperty的缺点</h4><ul><li>深度监听，需要一次性递归到底，计算量大</li><li>无法监听新增/删除属性（所以使用Vue的set和delete方法）</li><li>无法监听原生数组，需要特殊处理</li></ul><h3 id="数组监听"><a href="#数组监听" class="headerlink" title="数组监听"></a>数组监听</h3><h4 id="对数组进行重新定义"><a href="#对数组进行重新定义" class="headerlink" title="对数组进行重新定义"></a>对数组进行重新定义</h4><pre><code class="hljs js"><span class="hljs-comment">// 重新定义数组原型</span><span class="hljs-keyword">const</span> oldArrayProperty = <span class="hljs-built_in">Array</span>.prototype<span class="hljs-comment">// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型</span><span class="hljs-keyword">const</span> arrProto = <span class="hljs-built_in">Object</span>.create(oldArrayProperty);[<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-string">&#x27;pop&#x27;</span>, <span class="hljs-string">&#x27;shift&#x27;</span>, <span class="hljs-string">&#x27;unshift&#x27;</span>, <span class="hljs-string">&#x27;splice&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-params">methodName</span> =&gt;</span> &#123;    arrProto[methodName] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        updateView() <span class="hljs-comment">// 触发视图更新</span>        <span class="hljs-comment">// 在执行updateView后，任然能够继续执行数组对象原有的方法</span>        oldArrayProperty[methodName].call(<span class="hljs-built_in">this</span>, ...arguments)        <span class="hljs-comment">// 污染全局</span>        <span class="hljs-comment">// Array.prototype.push.call(this, ...arguments)</span>    &#125;&#125;)</code></pre><h4 id="修改observer"><a href="#修改observer" class="headerlink" title="修改observer"></a>修改observer</h4><pre><code class="hljs js"><span class="hljs-comment">// 监听对象属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observer</span>(<span class="hljs-params">target</span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target === <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 不是对象或数组</span>        <span class="hljs-keyword">return</span> target    &#125;    <span class="hljs-comment">// 污染全局的 Array 原型</span>    <span class="hljs-comment">// Array.prototype.push = function () &#123;</span>    <span class="hljs-comment">//     updateView()</span>    <span class="hljs-comment">//     ...</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(target)) &#123;        target.__proto__ = arrProto    &#125;    <span class="hljs-comment">// 重新定义各个属性（for in 也可以遍历数组）</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> target) &#123;        defineReactive(target, key, target[key])    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础二</title>
    <link href="/2018/01/22/vue/Vue%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <url>/2018/01/22/vue/Vue%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础学习笔记"><a href="#Vue基础学习笔记" class="headerlink" title="Vue基础学习笔记"></a>Vue基础学习笔记</h1><h2 id="循环渲染"><a href="#循环渲染" class="headerlink" title="循环渲染"></a>循环渲染</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>遍历数组<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in listArr&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>                &#123;&#123;index&#125;&#125; - &#123;&#123;item.id&#125;&#125; - &#123;&#123;item.title&#125;&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>遍历对象<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(val, key, index) in listObj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;</span>                &#123;&#123;index&#125;&#125; - &#123;&#123;key&#125;&#125; -  &#123;&#123;val.title&#125;&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            flag: <span class="hljs-literal">false</span>,</span>            listArr: [<span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题1&#x27;</span> &#125;, <span class="hljs-comment">// 数据结构中，最好有 id ，方便使用 key</span></span><span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题2&#x27;</span> &#125;,</span><span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题3&#x27;</span> &#125;</span>            ],            listObj: &#123;<span class="javascript">                a: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题1&#x27;</span> &#125;,</span><span class="javascript">                b: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题2&#x27;</span> &#125;,</span><span class="javascript">                c: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题3&#x27;</span> &#125;,</span>            &#125;        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><ul><li>v-for不光能遍历数组，也可以遍历对象</li><li>v-for和v-if不能同时使用</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment1&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment2(2, $event)&quot;</span>&gt;</span>+2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span>            num: 0        &#125;    &#125;,    methods: &#123;        increment1(event) &#123;<span class="javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;event&#x27;</span>, event, event.__proto__.constructor) <span class="hljs-comment">// 是原生的 event 对象</span></span><span class="javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><span class="javascript">            <span class="hljs-built_in">console</span>.log(event.target)</span><span class="javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><span class="javascript">            <span class="hljs-built_in">console</span>.log(event.currentTarget) <span class="hljs-comment">// 注意，事件是被注册到当前元素的，和 React 不一样</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.num++</span><span class="javascript">            <span class="hljs-comment">// 1. event 是原生的</span></span><span class="javascript">            <span class="hljs-comment">// 2. 事件被挂载到当前元素</span></span><span class="javascript">            <span class="hljs-comment">// 和 DOM 事件一样</span></span>        &#125;,        increment2(val, event) &#123;<span class="javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><span class="javascript">            <span class="hljs-built_in">console</span>.log(event.target)</span><span class="javascript">            <span class="hljs-built_in">this</span>.num = <span class="hljs-built_in">this</span>.num + val</span>        &#125;,        loadHandler() &#123;<span class="javascript">            <span class="hljs-comment">// do some thing</span></span>        &#125;    &#125;,    mounted() &#123;<span class="javascript">        <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-built_in">this</span>.loadHandler)</span>    &#125;,    beforeDestroy() &#123;<span class="javascript">        <span class="hljs-comment">//【注意】用 vue 绑定的事件，组建销毁时会自动被解绑</span></span><span class="javascript">        <span class="hljs-comment">// 自己绑定的事件，需要自己销毁！！！</span></span><span class="javascript">        <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-built_in">this</span>.loadHandler)</span>    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>输入框: &#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;age&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>多行文本: &#123;&#123;desc&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 注意，&lt;textarea&gt;&#123;&#123;desc&#125;&#125;&lt;/textarea&gt; 是不允许的！！！ --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>复选框 &#123;&#123;checked&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checked&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>多个复选框 &#123;&#123;checkedNames&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jack&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span>Jack<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mike&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mike&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mike&quot;</span>&gt;</span>Mike<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>单选 &#123;&#123;gender&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>下拉列表选择 &#123;&#123;selected&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>下拉列表选择（多选） &#123;&#123;selectedList&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selectedList&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            name: <span class="hljs-string">&#x27;双越&#x27;</span>,</span>            age: 18,<span class="javascript">            desc: <span class="hljs-string">&#x27;自我介绍&#x27;</span>,</span><span class="javascript">            checked: <span class="hljs-literal">true</span>,</span>            checkedNames: [],<span class="javascript">            gender: <span class="hljs-string">&#x27;male&#x27;</span>,</span><span class="javascript">            selected: <span class="hljs-string">&#x27;&#x27;</span>,</span>            selectedList: []        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础一</title>
    <link href="/2018/01/20/vue/Vue%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <url>/2018/01/20/vue/Vue%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础学习笔记"><a href="#Vue基础学习笔记" class="headerlink" title="Vue基础学习笔记"></a>Vue基础学习笔记</h1><h2 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>文本插值 &#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>JS 表达式 &#123;&#123; flag ? &#x27;yes&#x27; : &#x27;no&#x27; &#125;&#125; （只能是表达式，不能是 js 语句）<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span>动态属性 id<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>有 xss 风险<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>【注意】使用 v-html 之后，将会覆盖子元素<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 其他常用指令后面讲 --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            message: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="javascript">            flag: <span class="hljs-literal">true</span>,</span><span class="handlebars"><span class="xml">            rawHtml: &#x27;指令 - 原始 html <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>加粗<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>&#x27;,</span></span><span class="javascript">            dynamicId: <span class="hljs-string">`id-<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span></span>        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h2 id="computed和watch"><a href="#computed和watch" class="headerlink" title="computed和watch"></a>computed和watch</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>一个计算属性,类似于过滤器,对绑定到view的数据进行处理。</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data: &#123;        firstName: <span class="hljs-string">&#x27;Foo&#x27;</span>,        lastName: <span class="hljs-string">&#x27;Bar&#x27;</span>    &#125;,    computed: &#123;        fullName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName        &#125;    &#125;&#125;</code></pre><p><strong>fullName不可在data里面定义</strong></p><h4 id="get和set用法"><a href="#get和set用法" class="headerlink" title="get和set用法"></a>get和set用法</h4><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data: &#123;        firstName: <span class="hljs-string">&#x27;Foo&#x27;</span>,        lastName: <span class="hljs-string">&#x27;Bar&#x27;</span>    &#125;,    computed: &#123;        fullName:&#123;            get()&#123;<span class="hljs-comment">//回调函数 当需要读取当前属性值是执行，根据相关数据计算并返回当前属性的值</span>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName            &#125;,            set(val)&#123;<span class="hljs-comment">//监视当前属性值的变化，当属性值发生变化时执行，更新相关的属性数据</span>                <span class="hljs-comment">//val就是fullName的最新属性值</span>                <span class="hljs-built_in">console</span>.log(val)                <span class="hljs-keyword">const</span> names = val.split(<span class="hljs-string">&#x27; &#x27;</span>);                <span class="hljs-built_in">console</span>.log(names)                <span class="hljs-built_in">this</span>.firstName = names[<span class="hljs-number">0</span>];                <span class="hljs-built_in">this</span>.lastName = names[<span class="hljs-number">1</span>];            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>computed有缓存，data不变则不会重新计算</strong></p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>watch是一个观察的动作</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data: &#123;        firstName: <span class="hljs-string">&#x27;Foo&#x27;</span>,        lastName: <span class="hljs-string">&#x27;Bar&#x27;</span>,        fullName: <span class="hljs-string">&#x27;Foo Bar&#x27;</span>    &#125;,    watch: &#123;        firstName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;            <span class="hljs-built_in">this</span>.fullName = val + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName        &#125;,        lastName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;            <span class="hljs-built_in">this</span>.fullName = <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + val        &#125;    &#125;&#125;</code></pre><h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data() &#123;        <span class="hljs-keyword">return</span>&#123;            <span class="hljs-string">&#x27;first&#x27;</span>:<span class="hljs-number">2</span>        &#125;    &#125;,    watch: &#123;        first()&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.first)        &#125;    &#125;,&#125;</code></pre><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data()&#123;        <span class="hljs-keyword">return</span>&#123;            <span class="hljs-string">&#x27;first&#x27;</span>:&#123;                second:<span class="hljs-number">0</span>            &#125;        &#125;    &#125;,    watch:&#123;        secondChange:&#123;            handler(oldVal,newVal)&#123;                <span class="hljs-built_in">console</span>.log(oldVal)                <span class="hljs-built_in">console</span>.log(newVal)            &#125;,            deep:<span class="hljs-literal">true</span>        &#125;    &#125;&#125;</code></pre><ul><li><p><strong>console.log打印的结果,发现oldVal和newVal值是一样的,所以深度监听虽然可以监听到对象的变化,但是无法监听到具体对象里面那个属性的变化（只针对引用类型）</strong></p></li><li><p>oldVal和newVal值一样的原因是它们索引同一个对象/数组。Vue <strong>不会保留修改之前值的副本</strong></p></li><li><p>深度监听对应的函数名必须为handler,否则无效果,因为watcher里面对应的是对handler的调用</p></li></ul><h4 id="监听对象单个属性"><a href="#监听对象单个属性" class="headerlink" title="监听对象单个属性"></a>监听对象单个属性</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data() &#123;        <span class="hljs-keyword">return</span> &#123;            first: &#123;                second: <span class="hljs-number">0</span>            &#125;        &#125;;    &#125;,    watch: &#123;        <span class="hljs-string">&quot;first.second&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newVal, oldVal</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(newVal, oldVal);        &#125;    &#125;&#125;</code></pre><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>用computed作为中间件转化,因为computed可以取到对应的属性值</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data() &#123;        <span class="hljs-keyword">return</span> &#123;            first: &#123;                second: <span class="hljs-number">0</span>                &#125;            &#125;;    &#125;,    computed: &#123;        secondChange() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.first.second;        &#125;    &#125;,    watch: &#123;        secondChange() &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;second属性值变化了&quot;</span>);        &#125;    &#125;&#125;</code></pre><h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><h4 id="computed特性"><a href="#computed特性" class="headerlink" title="computed特性"></a>computed特性</h4><ol><li>是计算值</li><li>应用：就是简化tempalte里面双花括号计算和处理props或$emit的传值</li><li>具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数</li></ol><h4 id="watch特性"><a href="#watch特性" class="headerlink" title="watch特性"></a>watch特性</h4><ol><li>是观察的动作</li><li>应用：监听props，$emit或本组件的值执行异步操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ol><h2 id="class和style"><a href="#class和style" class="headerlink" title="class和style"></a>class和style</h2><ul><li>使用动态属性</li><li>使用驼峰式写法</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; black: isBlack, yellow: isYellow &#125;&quot;</span>&gt;</span>使用 class<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[black, yellow]&quot;</span>&gt;</span>使用 class （数组）<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleData&quot;</span>&gt;</span>使用 style<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            isBlack: <span class="hljs-literal">true</span>,</span><span class="javascript">            isYellow: <span class="hljs-literal">true</span>,</span><span class="javascript">            black: <span class="hljs-string">&#x27;black&#x27;</span>,</span><span class="javascript">            yellow: <span class="hljs-string">&#x27;yellow&#x27;</span>,</span>            styleData: &#123;<span class="javascript">                fontSize: <span class="hljs-string">&#x27;40px&#x27;</span>, <span class="hljs-comment">// 转换为驼峰式</span></span><span class="javascript">                color: <span class="hljs-string">&#x27;red&#x27;</span>,</span><span class="javascript">                backgroundColor: <span class="hljs-string">&#x27;#ccc&#x27;</span> <span class="hljs-comment">// 转换为驼峰式</span></span>            &#125;        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.black</span> &#123;</span><span class="css">        <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#999</span>;</span>    &#125;<span class="css">    <span class="hljs-selector-class">.yellow</span> &#123;</span>        color: yellow;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;a&#x27;&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;b&#x27;&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>other<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;type === &#x27;a&#x27;&quot;</span>&gt;</span>A by v-show<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;type === &#x27;b&#x27;&quot;</span>&gt;</span>B by v-show<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            type: <span class="hljs-string">&#x27;a&#x27;</span></span>        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h4 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h4><ul><li>v-if是false时候不会渲染dom，v-show则是display:none</li><li>频繁切换使用v-show,不会频繁渲染dom</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RainbowSort [要求 Tc: O(n) Sc:O(1)]</title>
    <link href="/2017/11/09/algorithm/RainbowSort/"/>
    <url>/2017/11/09/algorithm/RainbowSort/</url>
    
    <content type="html"><![CDATA[<p>给定一系列球，其中球的颜色只能是红色，黄色或蓝色，对球进行排序，以使所有红色球都分组在左侧，所有黄色球都分组在中间，所有蓝色球分组在右侧。</p><p>例：</p><blockquote><p>[红] 被排序为 [红]</p></blockquote><blockquote><p>[黄，红] 被排序为 [红，黄]</p></blockquote><blockquote><p>[黄, 红, 红, 蓝, 黄, 红, 蓝] 被排序为 [红, 红, 红, 黄, 黄, 蓝, 蓝]</p></blockquote><p>假设条件:</p><blockquote><p>输入数组不为 null。</p></blockquote><p>corner case:</p><p>如果输入数组的长度为零怎么办？在这种情况下，我们应该直接返回空数组。</p><p><strong>解法：</strong></p><p><strong>思路:</strong> 本题思路是挡板思想, 使用三个挡板四个区域的思想进行划分 (交换数组元素位置)</p><p><strong>挡板的物理意义: [0-i) 全是红色,[i,j) 之间为黄色,(k-&gt;n-1] 全为蓝色，[j-k] 为未知探索区域</strong></p><p>j 为快指针</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = [<span class="hljs-string">&#x27;黄&#x27;</span>,<span class="hljs-string">&#x27;红&#x27;</span>,<span class="hljs-string">&#x27;红&#x27;</span>,<span class="hljs-string">&#x27;蓝&#x27;</span>,<span class="hljs-string">&#x27;黄&#x27;</span>,<span class="hljs-string">&#x27;红&#x27;</span>,<span class="hljs-string">&#x27;蓝&#x27;</span>]<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rainbowSort</span>(<span class="hljs-params">rainbow</span>) </span>&#123;    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = rainbow.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (j &lt;= k) &#123;        <span class="hljs-keyword">if</span> (rainbow[j] === <span class="hljs-string">&#x27;红&#x27;</span>) &#123;            swap(rainbow,i,j);            i++;            j++;        &#125;        <span class="hljs-keyword">if</span> (rainbow[j] === <span class="hljs-string">&#x27;黄&#x27;</span>) &#123;            j++;        &#125;        <span class="hljs-keyword">if</span> (rainbow[j] === <span class="hljs-string">&#x27;蓝&#x27;</span>) &#123;            swap(rainbow, j, k); <span class="hljs-comment">//这里不写j++是因为从k交换过来的元素不能保证就是黄色,为了安全起见下次循环再检查一次j位置。</span>            k--;        &#125;    &#125;&#125;<span class="hljs-comment">//辅助交换函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">arr,i,j</span>) </span>&#123;    [arr[i],arr[j]] = [arr[j],arr[i]]&#125;rainbowSort(input);<span class="hljs-built_in">console</span>.log(input);</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现new、bind、instanceOf、deepClone</title>
    <link href="/2017/08/21/write-code%20/write-code/"/>
    <url>/2017/08/21/write-code%20/write-code/</url>
    
    <content type="html"><![CDATA[<h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> New = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Fn</span>) </span>&#123;  <span class="hljs-keyword">var</span> obj = &#123;&#125;; <span class="hljs-comment">// 创建空对象</span>  <span class="hljs-keyword">var</span> arg = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);  obj.__proto__ = Fn.prototype; <span class="hljs-comment">// 将obj的原型链__proto__指向构造函数的原型prototype</span>  obj.__proto__.constructor = Fn; <span class="hljs-comment">// 在原型链 __proto__上设置构造函数的构造器constructor，为了实例化Fn</span>  Fn.apply(obj, arg); <span class="hljs-comment">// 执行Fn，并将构造函数Fn执行obj</span>  <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 返回结果</span>&#125;;</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> getType = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-comment">// 获取数据类型</span>  <span class="hljs-keyword">const</span> baseType = <span class="hljs-built_in">Object</span>.prototype.toString    .call(data)    .replace(<span class="hljs-regexp">/^\[object\s(.+)\]$/g</span>, <span class="hljs-string">&quot;$1&quot;</span>)    .toLowerCase();  <span class="hljs-keyword">const</span> type = data <span class="hljs-keyword">instanceof</span> Element ? <span class="hljs-string">&quot;element&quot;</span> : baseType;  <span class="hljs-keyword">return</span> type;&#125;;<span class="hljs-keyword">const</span> isPrimitive = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-comment">// 判断是否是基本数据类型</span>  <span class="hljs-keyword">const</span> primitiveType = <span class="hljs-string">&quot;undefined,null,boolean,string,symbol,number,bigint,map,set,weakmap,weakset&quot;</span>.split(    <span class="hljs-string">&quot;,&quot;</span>  ); <span class="hljs-comment">// 其实还有很多类型</span>  <span class="hljs-keyword">return</span> primitiveType.includes(getType(data));&#125;;<span class="hljs-keyword">const</span> isObject = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> getType(data) === <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-keyword">const</span> isArray = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> getType(data) === <span class="hljs-string">&quot;array&quot;</span>;<span class="hljs-keyword">const</span> deepClone = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-keyword">let</span> cache = &#123;&#125;; <span class="hljs-comment">// 缓存值，防止循环引用</span>  <span class="hljs-keyword">const</span> baseClone = <span class="hljs-function"><span class="hljs-params">_data</span> =&gt;</span> &#123;    <span class="hljs-keyword">let</span> res;    <span class="hljs-keyword">if</span> (isPrimitive(_data)) &#123;      <span class="hljs-keyword">return</span> data;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(_data)) &#123;      res = &#123; ..._data &#125;;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isArray(_data)) &#123;      res = [..._data];    &#125;    <span class="hljs-comment">// 判断是否有复杂类型的数据，有就递归</span>    <span class="hljs-built_in">Reflect</span>.ownKeys(res).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (res[key] &amp;&amp; getType(res[key]) === <span class="hljs-string">&quot;object&quot;</span>) &#123;        <span class="hljs-comment">// 用cache来记录已经被复制过的引用地址。用来解决循环引用的问题</span>        <span class="hljs-keyword">if</span> (cache[res[key]]) &#123;          res[key] = cache[res[key]];        &#125; <span class="hljs-keyword">else</span> &#123;          cache[res[key]] = res[key];          res[key] = baseClone(res[key]);        &#125;      &#125;    &#125;);    <span class="hljs-keyword">return</span> res;  &#125;;  <span class="hljs-keyword">return</span> baseClone(data);&#125;;</code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.bind2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;...&quot;</span>);  &#125;  <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">var</span> args1 = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);  <span class="hljs-keyword">var</span> bindFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> args2 = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);    <span class="hljs-keyword">var</span> that2 = <span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> bindFn ? <span class="hljs-built_in">this</span> : context; <span class="hljs-comment">// 如果当前函数的this指向的是构造函数中的this 则判定为new 操作。如果this是构造函数bindFn new出来的实例，那么此处的this一定是该实例本身。</span>    <span class="hljs-keyword">return</span> that.apply(that2, args1.concat(args2));  &#125;;  <span class="hljs-keyword">var</span> Fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;; <span class="hljs-comment">// 连接原型链用Fn</span>  <span class="hljs-comment">// 原型赋值</span>  Fn.prototype = <span class="hljs-built_in">this</span>.prototype; <span class="hljs-comment">// bindFn的prototype指向和this的prototype一样，指向同一个原型对象</span>  bindFn.prototype = <span class="hljs-keyword">new</span> Fn();  <span class="hljs-keyword">return</span> bindFn;&#125;;</code></pre><h3 id="instanceOf"><a href="#instanceOf" class="headerlink" title="instanceOf"></a>instanceOf</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> instanceOf = <span class="hljs-function">(<span class="hljs-params">left, right</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> proto = left.__proto__;  <span class="hljs-keyword">let</span> prototype = right.prototype;  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proto === prototype) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    proto = proto.__proto__;  &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>手撕代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>手撕代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>twoSum [要求 Tc: O(n) Sc:O(n)]</title>
    <link href="/2017/05/07/algorithm/twoSum/"/>
    <url>/2017/05/07/algorithm/twoSum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum/">LeetCode 第 1 题</a></p><p>按照题目要求, 我们第一时间想到的会是两层循环暴力解法：</p><h4 id="解法1-Time-O-n²-Space-O-1"><a href="#解法1-Time-O-n²-Space-O-1" class="headerlink" title="解法1: Time = O(n²), Space = O(1)"></a><strong>解法1: Time = O(n²), Space = O(1)</strong></h4><p>思路: 遍历每个元素 nums[j]，并查找是否存在一个值与 target - nums[j] 相等的目标元素。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">nums, target</span>) </span>&#123;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;             <span class="hljs-keyword">if</span> (nums[j] == target - nums[i]) &#123;                 <span class="hljs-keyword">return</span> [i,j];             &#125;         &#125;     &#125;     <span class="hljs-keyword">return</span> [];&#125;</code></pre><h4 id="解法2-Time-O-n-Space-O-n"><a href="#解法2-Time-O-n-Space-O-n" class="headerlink" title="解法2: Time = O(n), Space = O(n)"></a><strong>解法2: Time = O(n), Space = O(n)</strong></h4><p>我们可以通过哈希表空间换时间。在进行迭代并将元素插入到表中的同时，我们回过头来检查哈希表中是否已经存在当前元素所对应的目标元素，如果存在，那我们就找到了问题的解，将其返回即可.(时间复杂度为 O(n), 空间复杂度也为 O(n))</p><p>符合题目要求 bingo✌</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;    <span class="hljs-keyword">let</span> reduceHash = &#123;&#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;        <span class="hljs-keyword">let</span> reduceResult = target - nums[i];        <span class="hljs-keyword">if</span> (reduceHash[reduceResult] !== <span class="hljs-literal">undefined</span>) &#123;            <span class="hljs-keyword">return</span> [reduceHash[reduceResult], i];        &#125;        reduceHash[nums[i]] = i;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
