<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue最全知识点，面试必备</title>
    <link href="/2020/09/24/vue/Vue%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/"/>
    <url>/2020/09/24/vue/Vue%E6%9C%80%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本篇文章纯属笔记性文章，非整体原创，是对vue知识的整理，对自己有很大帮助才分享出来，参考文章传送：</p><ol><li><a href="https://juejin.im/post/6844904084374290446">童欧巴对vue知识的整理</a> </li><li><a href="https://juejin.im/post/6844903918753808398">我是你的超级英雄对vue知识的整理</a> </li><li><a href="https://cn.vuejs.org/index.html">vue官网</a></li></ol></blockquote><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="说说你对MVVM的理解"><a href="#说说你对MVVM的理解" class="headerlink" title="说说你对MVVM的理解"></a>说说你对MVVM的理解</h3><ul><li>Model-View-ViewModel的缩写，Model代表数据模型，View代表UI组件,ViewModel将Model和View关联起来</li><li>数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据</li></ul><blockquote><p><a href="https://juejin.im/post/6844904115324223495">了解mvc/mvp/mvvm的区别</a></p></blockquote><h2 id="Vue2-x响应式数据-双向绑定原理"><a href="#Vue2-x响应式数据-双向绑定原理" class="headerlink" title="Vue2.x响应式数据/双向绑定原理"></a>Vue2.x响应式数据/双向绑定原理</h2><ul><li>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何根据Data变化更新View。</li><li>简述：<ul><li>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。</li><li>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。</li><li>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</li></ul></li></ul><p><img src="/images/pages/virtual-dom.png" alt="virtual-dom"></p><h3 id="深入理解："><a href="#深入理解：" class="headerlink" title="深入理解："></a>深入理解：</h3><ul><li>监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li><li>解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li><li>订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式</li><li>订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</li></ul><h2 id="你知道Vue3-x响应式数据原理吗？"><a href="#你知道Vue3-x响应式数据原理吗？" class="headerlink" title="你知道Vue3.x响应式数据原理吗？"></a>你知道Vue3.x响应式数据原理吗？</h2><h3 id="Vue3-x改用Proxy替代Object-defineProperty"><a href="#Vue3-x改用Proxy替代Object-defineProperty" class="headerlink" title="Vue3.x改用Proxy替代Object.defineProperty"></a>Vue3.x改用Proxy替代Object.defineProperty</h3><ul><li>因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</li><li>Proxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？<ul><li>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。</li><li>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</li></ul></li></ul><h3 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h3><ul><li><p>Proxy 的优势如下:</p><ul><li>Proxy 可以直接监听对象而非属性；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul></li><li><p>Object.defineProperty 的优势如下:</p><ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li></ul></li></ul><h2 id="VUEX篇"><a href="#VUEX篇" class="headerlink" title="VUEX篇"></a>VUEX篇</h2><h3 id="Vuex-是什么？"><a href="#Vuex-是什么？" class="headerlink" title="Vuex 是什么？"></a>Vuex 是什么？</h3><blockquote><p>运用到了js设计模式中的单例模式，单例模式想要做到的是，不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。</p></blockquote><ul><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</li><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul><blockquote><p>Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 ——Vuex官方文档</p></blockquote><p>主要包括以下几个模块：</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><h3 id="什么情况下使用-Vuex？"><a href="#什么情况下使用-Vuex？" class="headerlink" title="什么情况下使用 Vuex？"></a>什么情况下使用 Vuex？</h3><ul><li>如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可</li><li>需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态</li></ul><h3 id="Vuex和单纯的全局对象有什么区别？"><a href="#Vuex和单纯的全局对象有什么区别？" class="headerlink" title="Vuex和单纯的全局对象有什么区别？"></a>Vuex和单纯的全局对象有什么区别？</h3><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ul><h3 id="为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="为什么 Vuex 的 mutation 中不能做异步操作？"></a>为什么 Vuex 的 mutation 中不能做异步操作？</h3><ul><li>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li><li>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li></ul><h3 id="vuex的action有返回值吗？返回的是什么？"><a href="#vuex的action有返回值吗？返回的是什么？" class="headerlink" title="vuex的action有返回值吗？返回的是什么？"></a>vuex的action有返回值吗？返回的是什么？</h3><ul><li>store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise</li><li>Action 通常是异步的，要知道 action 什么时候结束或者组合多个 action以处理更加复杂的异步流程，可以通过定义action时返回一个promise对象，就可以在派发action的时候就可以通过处理返回的 Promise处理异步流程<blockquote><p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote></li></ul><h3 id="新增：为什么不直接分发mutation-而要通过分发action之后提交-mutation变更状态"><a href="#新增：为什么不直接分发mutation-而要通过分发action之后提交-mutation变更状态" class="headerlink" title="新增：为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态"></a>新增：为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态</h3><ul><li>mutation 必须同步执行，我们可以在 action 内部执行异步操作</li><li>可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）</li></ul><h2 id="常规篇"><a href="#常规篇" class="headerlink" title="常规篇"></a>常规篇</h2><h3 id="computed-和-watch-的区别和运用的场景？"><a href="#computed-和-watch-的区别和运用的场景？" class="headerlink" title="computed 和 watch 的区别和运用的场景？"></a>computed 和 watch 的区别和运用的场景？</h3><ul><li>computed：是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</li><li>watch：没有缓存性，更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听</li><li>运用场景：<ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用watch选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul></li></ul><h3 id="Vue2-x组件通信有哪些方式？"><a href="#Vue2-x组件通信有哪些方式？" class="headerlink" title="Vue2.x组件通信有哪些方式？"></a>Vue2.x组件通信有哪些方式？</h3><ul><li>父子组件通信<ul><li>事件机制(**父-&gt;子props,子-&gt;父 $on、$emit)</li><li>获取父子组件实例 $parent、$children</li><li>Ref 获取实例的方式调用组件的属性或者方法</li><li>Provide、inject (不推荐使用，组件库时很常用)</li></ul></li><li>兄弟组件通信<ul><li>eventBus 这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件<blockquote><p>Vue.prototype.$bus = new Vue</p></blockquote></li></ul></li><li>跨级组件通信<ul><li>Vuex</li><li>$attrs、$listeners</li><li>Provide、inject</li></ul></li></ul><h3 id="说一下v-if和v-show的区别"><a href="#说一下v-if和v-show的区别" class="headerlink" title="说一下v-if和v-show的区别"></a>说一下v-if和v-show的区别</h3><ul><li>当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。</li><li>v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；</li><li>v-show 则适用于需要非常频繁切换条件的场景。</li></ul><h3 id="为什么-v-for-和-v-if-不建议用在一起"><a href="#为什么-v-for-和-v-if-不建议用在一起" class="headerlink" title="为什么 v-for 和 v-if 不建议用在一起"></a>为什么 v-for 和 v-if 不建议用在一起</h3><ul><li>当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费</li><li>这种场景建议使用 computed，先对数据进行过滤</li></ul><h3 id="组件中的data为什么是一个函数？"><a href="#组件中的data为什么是一个函数？" class="headerlink" title="组件中的data为什么是一个函数？"></a>组件中的data为什么是一个函数？</h3><ul><li>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。</li><li>如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</li></ul><h3 id="子组件为什么不可以修改父组件传递的Prop？怎么理解vue的单向数据流？"><a href="#子组件为什么不可以修改父组件传递的Prop？怎么理解vue的单向数据流？" class="headerlink" title="子组件为什么不可以修改父组件传递的Prop？怎么理解vue的单向数据流？"></a>子组件为什么不可以修改父组件传递的Prop？怎么理解vue的单向数据流？</h3><ul><li><p>Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。</p></li><li><p>这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解。</p></li><li><p>如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p><h3 id="v-model是如何实现双向绑定的？"><a href="#v-model是如何实现双向绑定的？" class="headerlink" title="v-model是如何实现双向绑定的？"></a>v-model是如何实现双向绑定的？</h3></li><li><p>v-model是用来在表单控件或者组件上创建双向绑定的</p></li><li><p>他的本质是v-bind和v-on的语法糖</p></li><li><p>在一个组件上使用v-model，默认会为组件绑定名为value的prop和名为input的事件</p></li></ul><h3 id="nextTick的实现原理是什么？"><a href="#nextTick的实现原理是什么？" class="headerlink" title="nextTick的实现原理是什么？"></a>nextTick的实现原理是什么？</h3><ul><li>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。</li><li>nextTick主要使用了宏任务和微任务。</li><li>根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</li></ul><h3 id="Vue不能检测数组的哪些变动？Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#Vue不能检测数组的哪些变动？Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="Vue不能检测数组的哪些变动？Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>Vue不能检测数组的哪些变动？Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h3><ul><li>Vue 不能检测以下数组的变动：<ul><li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如：vm.items.length = newLength</li><li>解决办法：<ul><li>第一类问题:  <pre><code class="hljs js"><span class="hljs-comment">// 法一：Vue.set</span>Vue.set(vm.items, indexOfItem, newValue)<span class="hljs-comment">// 法二：Array.prototype.splice</span>vm.items.splice(indexOfItem, <span class="hljs-number">1</span>, newValue)</code></pre></li><li>第二类问题，可使用 splice:  <pre><code class="hljs js">vm.items.splice(newLength)</code></pre></li></ul></li></ul></li></ul><p>vm.$set 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul><h3 id="Vue事件绑定原理是什么？"><a href="#Vue事件绑定原理是什么？" class="headerlink" title="Vue事件绑定原理是什么？"></a>Vue事件绑定原理是什么？</h3><ul><li>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。</li></ul><h3 id="说一下虚拟Dom以及key属性的作用"><a href="#说一下虚拟Dom以及key属性的作用" class="headerlink" title="说一下虚拟Dom以及key属性的作用"></a>说一下虚拟Dom以及key属性的作用</h3><ul><li>由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的产生原因。</li><li>Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。(也就是源码中的VNode类，它定义在src/core/vdom/vnode.js中。)</li><li>虚拟 DOM 的实现原理主要包括以下 3 部分：<ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li><li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li><li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul></li><li>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速<ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。</li><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul></li></ul><h3 id="为什么不建议用index作为key"><a href="#为什么不建议用index作为key" class="headerlink" title="为什么不建议用index作为key?"></a>为什么不建议用index作为key?</h3><ul><li>不建议 用index 作为 key，和没写基本上没区别，因为不管你数组的顺序怎么颠倒，index 都是 0, 1, 2 这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作</li></ul><h2 id="生命周期篇"><a href="#生命周期篇" class="headerlink" title="生命周期篇"></a>生命周期篇</h2><h3 id="说一下你对Vue的生命周期的理解"><a href="#说一下你对Vue的生命周期的理解" class="headerlink" title="说一下你对Vue的生命周期的理解"></a>说一下你对Vue的生命周期的理解</h3><ul><li><p>简单回答</p><ul><li>beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed。</li><li>keep-alive 有自己独立的钩子函数 activated 和 deactivated。</li></ul></li><li><p>复杂回答</p></li></ul><table><thead><tr><th>生命周期</th><th>发生了什么</th></tr></thead><tbody><tr><td>beforeCreate</td><td>在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问</td></tr><tr><td>created</td><td>在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom</td></tr><tr><td>beforeMount</td><td>发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated</td></tr><tr><td>mounted</td><td>在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作</td></tr><tr><td>beforeUpdate</td><td>发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染</td></tr><tr><td>updated</td><td>发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新</td></tr><tr><td>beforeDestroy</td><td>发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器</td></tr><tr><td>destroyed</td><td>发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁</td></tr><tr><td>activited keep-alive 专属</td><td>组件被激活时调用</td></tr><tr><td>deactivated keep-alive 专属</td><td>组件被销毁时调用</td></tr></tbody></table><h3 id="Vue中组件生命周期调用顺序是什么样的？"><a href="#Vue中组件生命周期调用顺序是什么样的？" class="headerlink" title="Vue中组件生命周期调用顺序是什么样的？"></a>Vue中组件生命周期调用顺序是什么样的？</h3><ul><li>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</li><li>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</li></ul><h3 id="在什么阶段才能访问操作DOM？"><a href="#在什么阶段才能访问操作DOM？" class="headerlink" title="在什么阶段才能访问操作DOM？"></a>在什么阶段才能访问操作DOM？</h3><ul><li>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。</li></ul><h3 id="你的接口请求一般放在哪个生命周期中？"><a href="#你的接口请求一般放在哪个生命周期中？" class="headerlink" title="你的接口请求一般放在哪个生命周期中？"></a>你的接口请求一般放在哪个生命周期中？</h3><ul><li>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</li><li>但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：<ul><li>能更快获取到服务端数据，减少页面loading 时间；</li><li>ssr不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul></li></ul><h2 id="路由篇"><a href="#路由篇" class="headerlink" title="路由篇"></a>路由篇</h2><h3 id="vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？"><a href="#vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？" class="headerlink" title="vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？"></a>vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？</h3><ul><li>hash 模式：<ul><li>后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面</li><li>通过监听 hashchange 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。</li></ul></li><li>history 模式：<ul><li>history 模式的实现，主要是 HTML5 标准发布的两个 API，pushState 和 replaceState，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作</li></ul></li><li>区别<ul><li>url 展示上，hash 模式有“#”，history 模式没有</li><li>刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由</li><li>兼容性， hash 可以支持低版本浏览器和 IE。</li></ul></li></ul><h3 id="路由懒加载是什么意思？如何实现路由懒加载？"><a href="#路由懒加载是什么意思？如何实现路由懒加载？" class="headerlink" title="路由懒加载是什么意思？如何实现路由懒加载？"></a>路由懒加载是什么意思？如何实现路由懒加载？</h3><ul><li>路由懒加载的含义：把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件</li><li>实现：结合 Vue 的异步组件和 Webpack 的代码分割功能<ol><li>可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)<pre><code class="hljs js"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve(&#123; <span class="hljs-comment">/* 组件定义对象 */</span> &#125;)</code></pre></li><li>在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)<pre><code class="hljs js"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Foo.vue&#x27;</span>) <span class="hljs-comment">// 返回 Promise</span></code></pre></li><li>结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件<pre><code class="hljs js"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Foo.vue&#x27;</span>)<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123; <span class="hljs-attr">routes</span>: [ &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/foo&#x27;</span>, <span class="hljs-attr">component</span>: Foo &#125; ]&#125;)</code></pre></li></ol></li><li>使用命名 chunk，和webpack中的魔法注释就可以把某个路由下的所有组件都打包在同个异步块 (chunk) 中<pre><code class="hljs js"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;group-foo&quot; */</span> <span class="hljs-string">&#x27;./Foo.vue&#x27;</span>)</code></pre></li></ul><h3 id="Vue-router-导航守卫有哪些"><a href="#Vue-router-导航守卫有哪些" class="headerlink" title="Vue-router 导航守卫有哪些"></a>Vue-router 导航守卫有哪些</h3><ul><li>全局前置/钩子：beforeEach、beforeResolve、afterEach</li><li>路由独享的守卫：beforeEnter</li><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><h3 id="说说vue和react的异同"><a href="#说说vue和react的异同" class="headerlink" title="说说vue和react的异同"></a>说说vue和react的异同</h3><ul><li>同<ul><li>使用 Virtual DOM提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li></ul></li><li>异<ul><li>在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树（除非使用PureComponent/shouldComponentUpdate），在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染在 </li><li>React 中，一切都是 JavaScript。不仅仅是 HTML 可以用 JSX 来表达，现在的潮流也越来越多地将 CSS 也纳入到 JavaScript 中来处理</li><li>Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统，所以有更丰富的生态系统</li><li>Vue 提供了CLI 脚手架，能让你通过交互式的脚手架引导非常容易地构建项目。你甚至可以使用它快速开发组件的原型。React 在这方面也提供了create-react-app，但是现在还存在一些局限性</li><li>React Native 能使你用相同的组件模型编写有本地渲染能力的 APP，Vue 和Weex会进行官方合作，Weex 是阿里巴巴发起的跨平台用户界面开发框架，同时也正在 Apache 基金会进行项目孵化，另一个选择是NativeScript-Vue，一个用 Vue.js 构建完全原生应用的NativeScript插件</li></ul></li></ul><h3 id="什么是-mixin-？"><a href="#什么是-mixin-？" class="headerlink" title="什么是 mixin ？"></a>什么是 mixin ？</h3><ul><li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li><li>如果你希望再多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li><li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li></ul><h3 id="在-Vue-实例中编写生命周期-hook-或其他-option-properties-时，为什么不使用箭头函数-？"><a href="#在-Vue-实例中编写生命周期-hook-或其他-option-properties-时，为什么不使用箭头函数-？" class="headerlink" title="在 Vue 实例中编写生命周期 hook 或其他 option/properties 时，为什么不使用箭头函数 ？"></a>在 Vue 实例中编写生命周期 hook 或其他 option/properties 时，为什么不使用箭头函数 ？</h3><ul><li>箭头函数自已没有定义 this 上下文中。</li><li>当你在 Vue 程序中使用箭头函数 ( =&gt; ) 时，this 关键字病不会绑定到 Vue 实例，因此会引发错误。所以强烈建议改用标准函数声明。</li></ul><h3 id="Vue模版编译原理知道吗，能简单说一下吗？"><a href="#Vue模版编译原理知道吗，能简单说一下吗？" class="headerlink" title="Vue模版编译原理知道吗，能简单说一下吗？"></a>Vue模版编译原理知道吗，能简单说一下吗？</h3><p>简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段（生成AST树/优化/codegen）：</p><ul><li>首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</li><li>Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</li><li>编译的最后一步是将优化后的AST树转换为可执行的代码。</li></ul><h3 id="diff算法说一下"><a href="#diff算法说一下" class="headerlink" title="diff算法说一下"></a>diff算法说一下</h3><ul><li>同级比较，再比较子节点</li><li>先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较都有子节点的情况(核心diff)</li><li>递归比较子节点</li></ul><h3 id="说说你对keep-alive组件的了解"><a href="#说说你对keep-alive组件的了解" class="headerlink" title="说说你对keep-alive组件的了解"></a>说说你对keep-alive组件的了解</h3><ul><li>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</li><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul><h3 id="说说你对SSR的了解"><a href="#说说你对SSR的了解" class="headerlink" title="说说你对SSR的了解"></a>说说你对SSR的了解</h3><ul><li>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</li><li>SSR的优势<ul><li>更好的SEO</li><li>首屏加载速度更快</li></ul></li><li>SSR的缺点<ul><li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子</li><li>当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境</li><li>更多的服务端负载</li></ul></li></ul><h3 id="你都做过哪些Vue的性能优化？"><a href="#你都做过哪些Vue的性能优化？" class="headerlink" title="你都做过哪些Vue的性能优化？"></a>你都做过哪些Vue的性能优化？</h3><ul><li><p>编码阶段</p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>SPA 页面采用keep-alive缓存组件</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul></li><li><p>SEO优化</p><ul><li>预渲染</li><li>服务端渲染SSR</li></ul></li><li><p>打包优化</p><ul><li>压缩代码</li><li>Tree Shaking/Scope Hoisting</li><li>使用cdn加载第三方模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li></ul></li><li><p>用户体验</p><ul><li>骨架屏</li><li>PWA</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul></li><li><p>vue2.x中如何监测数组变化？</p><ul><li>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，当调用数组api时，可以通知依赖更新。</li><li>如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li></ul></li></ul><h3 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><ul><li>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</li><li>优点：<ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul></li><li>缺点：<ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul></li></ul><h3 id="对于即将到来的-vue3-0-特性你有什么了解的吗？"><a href="#对于即将到来的-vue3-0-特性你有什么了解的吗？" class="headerlink" title="对于即将到来的 vue3.0 特性你有什么了解的吗？"></a>对于即将到来的 vue3.0 特性你有什么了解的吗？</h3><ul><li><p>监测机制的改变</p><ul><li>3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。</li><li>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</li></ul></li><li><p>只能监测属性，不能监测对象</p><ul><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul></li><li><p>模板</p><ul><li>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</li><li>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</li></ul></li><li><p>对象式的组件声明方式</p><ul><li>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</li><li>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</li></ul></li><li><p>其它方面的更改</p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 tree shaking 优化，提供了更多的内置功能。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架、库学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Http请求终止与拦截方法记录</title>
    <link href="/2020/08/19/solutions/Http%E8%AF%B7%E6%B1%82%E7%BB%88%E6%AD%A2%E4%B8%8E%E6%8B%A6%E6%88%AA%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/08/19/solutions/Http%E8%AF%B7%E6%B1%82%E7%BB%88%E6%AD%A2%E4%B8%8E%E6%8B%A6%E6%88%AA%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>基于axios的http请求响应拦截与请求拦截，可自动终止重复请求，也提供手动终止方法</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<span class="hljs-keyword">import</span> Cookies <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;js-cookie&#x27;</span>;<span class="hljs-keyword">import</span> &#123;clearLoginInfo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils&#x27;</span>;<span class="hljs-keyword">import</span> qs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;qs&#x27;</span>;<span class="hljs-keyword">import</span> isPlainObject <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash/isPlainObject&#x27;</span>;<span class="hljs-keyword">const</span> http = axios.create(&#123;    timeout: <span class="hljs-number">1000</span> * <span class="hljs-number">180</span>,    withCredentials: <span class="hljs-literal">true</span>&#125;);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加终止请求方法</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-variable">config</span></span></span><span class="hljs-comment"> */</span>http.cancelPending = <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (http.pendingRequests        &amp;&amp; http.pendingRequests[<span class="hljs-string">`<span class="hljs-subst">$&#123;config.url&#125;</span>&amp;<span class="hljs-subst">$&#123;config.method&#125;</span>`</span>]) &#123;        http.pendingRequests[<span class="hljs-string">`<span class="hljs-subst">$&#123;config.url&#125;</span>&amp;<span class="hljs-subst">$&#123;config.method&#125;</span>`</span>](<span class="hljs-string">&#x27;canceled&#x27;</span>); <span class="hljs-comment">// 执行取消操作</span>        <span class="hljs-keyword">delete</span> http.pendingRequests[<span class="hljs-string">`<span class="hljs-subst">$&#123;config.url&#125;</span>&amp;<span class="hljs-subst">$&#123;config.method&#125;</span>`</span>];    &#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 请求拦截</span><span class="hljs-comment"> */</span>http.interceptors.request.use(    (config) =&gt; &#123;        <span class="hljs-keyword">let</span> noCancel = <span class="hljs-literal">false</span>;        <span class="hljs-comment">// token</span>        <span class="hljs-built_in">Object</span>.defineProperty(config, <span class="hljs-string">&#x27;headers&#x27;</span>, &#123;            value: &#123;                ...config.headers,                access_token: Cookies.get(<span class="hljs-string">&#x27;token&#x27;</span>)            &#125;        &#125;);        <span class="hljs-keyword">if</span> (config.method === <span class="hljs-string">&#x27;get&#x27;</span>) &#123;            noCancel = config.params?.noCancel;            <span class="hljs-keyword">if</span> (noCancel != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">delete</span> config.params.noCancel;            &#125;            <span class="hljs-built_in">Object</span>.defineProperty(config, <span class="hljs-string">&#x27;params&#x27;</span>, &#123;                value: &#123;                    ...config.params,                    unique_t: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()                &#125;            &#125;);        &#125;        <span class="hljs-keyword">if</span> (isPlainObject(config.data)) &#123;            noCancel = config.data.noCancel;            <span class="hljs-keyword">if</span> (noCancel != <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">delete</span> config.data.noCancel;            &#125;            <span class="hljs-built_in">Object</span>.defineProperty(config, <span class="hljs-string">&#x27;data&#x27;</span>, &#123;                value: &#123;                    ...config.data                &#125;            &#125;);            <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^application\/x-www-form-urlencoded/</span>.test(                config.headers[<span class="hljs-string">&#x27;content-type&#x27;</span>])) &#123;                <span class="hljs-built_in">Object</span>.defineProperty(config, <span class="hljs-string">&#x27;data&#x27;</span>, &#123;                    value: qs.stringify(config.data)                &#125;);            &#125;        &#125;        <span class="hljs-keyword">if</span> (!noCancel &amp;&amp; http.cancelPending) &#123;            http.cancelPending(config); <span class="hljs-comment">// 如果没有配置阻止取消请求（noCancel），在一个请求发送前执行取消操作</span>            <span class="hljs-built_in">Object</span>.defineProperty(config, <span class="hljs-string">&#x27;cancelToken&#x27;</span>, &#123;                value: <span class="hljs-keyword">new</span> axios.CancelToken(<span class="hljs-function">(<span class="hljs-params">cancelFn</span>) =&gt;</span> &#123;                    <span class="hljs-keyword">if</span> (http.pendingRequests) &#123;                        http.pendingRequests[<span class="hljs-string">`<span class="hljs-subst">$&#123;config.url&#125;</span>&amp;<span class="hljs-subst">$&#123;config.method&#125;</span>`</span>] = cancelFn;                    &#125; <span class="hljs-keyword">else</span> &#123;                        http.pendingRequests = &#123;&#125;;                        http.pendingRequests[<span class="hljs-string">`<span class="hljs-subst">$&#123;config.url&#125;</span>&amp;<span class="hljs-subst">$&#123;config.method&#125;</span>`</span>] = cancelFn;                    &#125;                &#125;),                writable: <span class="hljs-literal">false</span>            &#125;);        &#125;        <span class="hljs-keyword">return</span> config;    &#125;,    (error) =&gt; &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);    &#125;);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 响应拦截</span><span class="hljs-comment"> */</span>http.interceptors.response.use(    (response) =&gt; &#123;        <span class="hljs-keyword">if</span> (http.cancelPending) &#123;            http.cancelPending(response.config);        &#125;        <span class="hljs-keyword">return</span> response.data;    &#125;,    (error) =&gt; &#123;        <span class="hljs-keyword">if</span> (error?.response?.status === <span class="hljs-number">401</span>) &#123;            clearLoginInfo();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);    &#125;);<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> http;</code></pre>]]></content>
    
    
    <categories>
      
      <category>工作杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>for循环全家桶</title>
    <link href="/2020/06/15/basic/for%E5%BE%AA%E7%8E%AF%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <url>/2020/06/15/basic/for%E5%BE%AA%E7%8E%AF%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    
    <content type="html"><![CDATA[<p>抵达战场的 5 方势力分别是<code>for</code> , <code>foreach</code> , <code>map</code> , <code>for...in</code> , <code>for...of</code></p><h2 id="自我介绍环节"><a href="#自我介绍环节" class="headerlink" title="自我介绍环节"></a>自我介绍环节</h2><a id="more"></a><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>我是遍历界最早出现的一方诸侯，在座的各位需称我一声爷爷。我能满足开发人员的绝大多数的需求。</p><pre><code class="hljs js"><span class="hljs-comment">// 遍历数组</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;    <span class="hljs-built_in">console</span>.log(i)          <span class="hljs-comment">// 索引，数组下标</span>    <span class="hljs-built_in">console</span>.log(arr[i])     <span class="hljs-comment">// 数组下标所对应的元素</span>&#125;<span class="hljs-comment">// 遍历对象</span><span class="hljs-keyword">let</span> profile = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;April&quot;</span>,<span class="hljs-attr">nickname</span>:<span class="hljs-string">&quot;二十七刻&quot;</span>,<span class="hljs-attr">country</span>:<span class="hljs-string">&quot;China&quot;</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, keys=<span class="hljs-built_in">Object</span>.keys(profile); i &lt; keys.length;i++)&#123;    <span class="hljs-built_in">console</span>.log(keys[i])            <span class="hljs-comment">// 对象的键值</span>    <span class="hljs-built_in">console</span>.log(profile[keys[i]])   <span class="hljs-comment">// 对象的键对应的值</span>&#125;<span class="hljs-comment">// 遍历字符串</span><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcdef&quot;</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; str.length ;i++)&#123;    <span class="hljs-built_in">console</span>.log(i)          <span class="hljs-comment">// 索引 字符串的下标</span>    <span class="hljs-built_in">console</span>.log(str[i])     <span class="hljs-comment">// 字符串下标所对应的元素</span>&#125;<span class="hljs-comment">// 遍历DOM 节点</span><span class="hljs-keyword">let</span> articleParagraphs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.article &gt; p&#x27;</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;articleParagraphs.length;i++)&#123;    articleParagraphs[i].classList.add(<span class="hljs-string">&quot;paragraph&quot;</span>);    <span class="hljs-comment">// 给class名为“article”节点下的 p 标签添加一个名为“paragraph” class属性。</span>&#125;</code></pre><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>我是 ES5 版本发布的。按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。我是 for 循环的加强版。</p><pre><code class="hljs js"><span class="hljs-comment">// 遍历数组</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];arr.forEach(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(i))<span class="hljs-comment">// logs 1</span><span class="hljs-comment">// logs 2</span><span class="hljs-comment">// logs 3</span><span class="hljs-comment">// 直接输出了数组的元素</span><span class="hljs-comment">//遍历对象</span><span class="hljs-keyword">let</span> profile = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;April&quot;</span>,<span class="hljs-attr">nickname</span>:<span class="hljs-string">&quot;二十七刻&quot;</span>,<span class="hljs-attr">country</span>:<span class="hljs-string">&quot;China&quot;</span>&#125;;<span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.keys(profile);keys.forEach(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(i)              <span class="hljs-comment">// 对象的键值</span>    <span class="hljs-built_in">console</span>.log(profile[i])     <span class="hljs-comment">// 对象的键对应的值</span>&#125;)</code></pre><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>我也是 ES5 版本发布的，我可以创建一个新数组，新数组的结果是原数组中的每个元素都调用一次提供的函数后的返回值。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<span class="hljs-keyword">let</span> res = arr.map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i * i);<span class="hljs-built_in">console</span>.log(res) <span class="hljs-comment">// logs [1, 4, 9, 16, 25]</span></code></pre><h3 id="for…in-枚举"><a href="#for…in-枚举" class="headerlink" title="for…in 枚举"></a>for…in 枚举</h3><p>我是 ES5 版本发布的。以任意顺序遍历一个对象的除 Symbol 以外的可枚举属性。</p><pre><code class="hljs js"><span class="hljs-comment">// 遍历对象</span><span class="hljs-keyword">let</span> profile = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;April&quot;</span>,<span class="hljs-attr">nickname</span>:<span class="hljs-string">&quot;二十七刻&quot;</span>,<span class="hljs-attr">country</span>:<span class="hljs-string">&quot;China&quot;</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> profile)&#123;    <span class="hljs-keyword">let</span> item = profile[i];    <span class="hljs-built_in">console</span>.log(item)   <span class="hljs-comment">// 对象的键值</span>    <span class="hljs-built_in">console</span>.log(i)      <span class="hljs-comment">// 对象的键对应的值</span>&#125;<span class="hljs-comment">// 遍历数组</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr)&#123;    <span class="hljs-keyword">let</span> item = arr[i];    <span class="hljs-built_in">console</span>.log(item)   <span class="hljs-comment">// 数组下标所对应的元素</span>    <span class="hljs-built_in">console</span>.log(i)      <span class="hljs-comment">// 索引，数组下标</span>&#125;<span class="hljs-comment">// 遍历字符串</span><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abcd&quot;</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> str)&#123;    <span class="hljs-keyword">let</span> item = str[i];    <span class="hljs-built_in">console</span>.log(item)   <span class="hljs-comment">// 字符串下标所对应的元素</span>    <span class="hljs-built_in">console</span>.log(i)      <span class="hljs-comment">// 索引 字符串的下标</span>&#125;</code></pre><h3 id="for…of-迭代"><a href="#for…of-迭代" class="headerlink" title="for…of 迭代"></a>for…of 迭代</h3><p>我是 ES6 版本发布的。在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p><pre><code class="hljs js"><span class="hljs-comment">// 迭代数组数组</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr)&#123;    <span class="hljs-built_in">console</span>.log(item)     &#125;<span class="hljs-comment">// logs &#x27;a&#x27;</span><span class="hljs-comment">// logs &#x27;b&#x27;</span><span class="hljs-comment">// logs &#x27;c&#x27;</span><span class="hljs-comment">// 迭代字符串</span><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> str) &#123;    <span class="hljs-built_in">console</span>.log(value);&#125;<span class="hljs-comment">// logs &#x27;a&#x27;</span><span class="hljs-comment">// logs &#x27;b&#x27;</span><span class="hljs-comment">// logs &#x27;c&#x27;</span><span class="hljs-comment">// 迭代map</span><span class="hljs-keyword">let</span> iterable = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>], [<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>], [<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>]]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> iterable) &#123;    <span class="hljs-built_in">console</span>.log(entry);&#125;<span class="hljs-comment">// logs [&quot;a&quot;, 1]</span><span class="hljs-comment">// logs [&quot;b&quot;, 2]</span><span class="hljs-comment">// logs [&quot;c&quot;, 3]</span><span class="hljs-comment">//  迭代map获取键值</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> iterable) &#123;    <span class="hljs-built_in">console</span>.log(key)    <span class="hljs-built_in">console</span>.log(value);&#125;<span class="hljs-comment">// 迭代set</span><span class="hljs-keyword">let</span> iterable = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>,<span class="hljs-number">4</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> iterable) &#123;    <span class="hljs-built_in">console</span>.log(value);&#125;<span class="hljs-comment">// logs 1</span><span class="hljs-comment">// logs 2</span><span class="hljs-comment">// logs 3</span><span class="hljs-comment">// logs 4</span><span class="hljs-comment">// 迭代 DOM 节点</span><span class="hljs-keyword">let</span> articleParagraphs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;.article &gt; p&#x27;</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> paragraph <span class="hljs-keyword">of</span> articleParagraphs) &#123;    paragraph.classList.add(<span class="hljs-string">&quot;paragraph&quot;</span>);    <span class="hljs-comment">// 给class名为“article”节点下的 p 标签添加一个名为“paragraph” class属性。</span>&#125;<span class="hljs-comment">// 迭代arguments类数组对象</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> argument <span class="hljs-keyword">of</span> <span class="hljs-built_in">arguments</span>) &#123;    <span class="hljs-built_in">console</span>.log(argument);  &#125;&#125;)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">// logs：</span><span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span><span class="hljs-comment">// 3</span><span class="hljs-comment">// 迭代类型数组</span><span class="hljs-keyword">let</span> typeArr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>([<span class="hljs-number">0x00</span>, <span class="hljs-number">0xff</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> typeArr) &#123;  <span class="hljs-built_in">console</span>.log(value);&#125;<span class="hljs-comment">// logs：</span><span class="hljs-comment">// 0</span><span class="hljs-comment">// 255</span></code></pre><p>经过第一轮的自我介绍和技能展示后，我们了解到:</p><ul><li><code>for语句</code>是最原始的循环语句。定义一个变量<code>i</code>(数字类型，表示数组的下标), 按照一定的条件，对<code>i</code>进行循环累加。条件通常为循环对象的长度，当超过长度就停止循环。因为对象无法判断长度，所以搭配<code>Object.keys()</code>使用。</li><li><code>forEach</code> ES5 提出。自称是<code>for语句</code>的加强版，可以发现它比<code>for语句</code>在写法上简单了很多。但是本质上也是数组的循环。<code>forEach</code>每个数组元素执行一次 callback 函数。也就是调用它的数组，因此，不会改变原数组。返回值是<code>undefine</code>。</li><li><code>map</code> ES5 提出。给原数组中的每个元素都按顺序调用一次 callback 函数。生成一个新数组，不修改调用它的原数组本身。返回值是新的数组。</li><li><code>for...in</code> ES5 提出。遍历对象上的可枚举属性，包括原型对象上的属性，且按任意顺序进行遍历，也就是顺序不固定。遍历数组时把数组的下标当作键值，此时的 i 是个字符串型的。它是为遍历对象属性而构建的，不建议与数组一起使用。</li><li><code>for...of</code> ES6 提出。只遍历可迭代对象的数据。</li></ul><h2 id="能力甄别"><a href="#能力甄别" class="headerlink" title="能力甄别"></a>能力甄别</h2><p>作为一个程序员，仅仅认识他们是远远不够的，在实际开发中鉴别他们各自的优缺点。因地制宜的使用他们，扬长避短。从而提高程序的整体性能才是能力之所在。</p><h3 id="关于跳出循环体"><a href="#关于跳出循环体" class="headerlink" title="关于跳出循环体"></a>关于跳出循环体</h3><p>在循环中满足一定条件就跳出循环体，或者跳过不符合条件的数据继续循环其它数据。是经常会遇到的需求。常用的语句是<code>break</code> 与 <code>continue</code>。</p><p>简单的说一下二者的区别，就当复习好了。</p><ul><li><code>break</code>语句是跳出当前循环，并执行当前循环之后的语句；</li><li><code>continue</code>语句是终止当前循环，并继续执行下一次循环;</li></ul><p><strong>注意</strong>：<code>forEach</code> 与<code>map</code> 是不支持跳出循环体的，其它三种方法均支持。</p><p><strong>原理</strong> ：查看<code>forEach</code>实现原理，就会理解这个问题。</p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.forEach(callbackfn)</code></pre><p>传入的 function 是这里的回调函数。在回调函数里面使用 break 肯定是非法的，因为 break 只能用于跳出循环，回调函数不是循环体。</p><p>在回调函数中使用 return，只是将结果返回到上级函数，也就是这个 for 循环中，并没有结束 for 循环，所以 return 也是无效的。</p><p><code>map()</code> 同理。</p><h3 id="map-链式调用"><a href="#map-链式调用" class="headerlink" title="map()链式调用"></a><code>map()</code>链式调用</h3><p><code>map()</code> 方法是可以链式调用的，这意味着它可以方便的结合其它方法一起使用。例如：<code>reduce()</code>, <code>sort()</code>, <code>filter()</code> 等。但是其它方法并不能做到这一点。<code>forEach()</code>的返回值是<code>undefined</code>，所以无法链式调用。</p><pre><code class="hljs js"><span class="hljs-comment">// 将元素乘以本身，再进行求和。</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">let</span> res1 = arr.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * item).reduce(<span class="hljs-function">(<span class="hljs-params">total, value</span>) =&gt;</span> total + value);<span class="hljs-built_in">console</span>.log(res1) <span class="hljs-comment">// logs 55 undefined&quot;</span></code></pre><h3 id="for-in会遍历出原型对象上的属性"><a href="#for-in会遍历出原型对象上的属性" class="headerlink" title="for...in会遍历出原型对象上的属性"></a><code>for...in</code>会遍历出原型对象上的属性</h3><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.prototype.objCustom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-built_in">Array</span>.prototype.arrCustom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];arr.foo = <span class="hljs-string">&#x27;hello&#x27;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arr) &#123;    <span class="hljs-built_in">console</span>.log(i);&#125;<span class="hljs-comment">// logs</span><span class="hljs-comment">// 0</span><span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span><span class="hljs-comment">// foo</span><span class="hljs-comment">// arrCustom</span><span class="hljs-comment">// objCustom</span></code></pre><p>然而在实际的开发中，我们并不需要原型对象上的属性。这种情况下我们可以使用<code>hasOwnProperty()</code> 方法，它会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）。如下：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.prototype.objCustom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-built_in">Array</span>.prototype.arrCustom = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];arr.foo = <span class="hljs-string">&#x27;hello&#x27;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> arr) &#123;    <span class="hljs-keyword">if</span> (arr.hasOwnProperty(i)) &#123;        <span class="hljs-built_in">console</span>.log(i);    &#125;&#125;<span class="hljs-comment">// logs</span><span class="hljs-comment">// 0</span><span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span><span class="hljs-comment">// foo</span><span class="hljs-comment">// 可见数组本身的属性还是无法摆脱。此时建议使用 forEach</span></code></pre><p>对于纯对象的遍历，选择<code>for..in</code>枚举更方便；对于数组遍历，如果不需要知道索引<code>for..of</code>迭代更合适，因为还可以中断；如果需要知道索引，则<code>forEach()</code>更合适；对于其他字符串，类数组，类型数组的迭代，<code>for..of</code>更占上风更胜一筹。但是注意低版本浏览器的是配性。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>有兴趣的读者可以找一组数据自行测试，文章就直接给出结果了，并做相应的解释。</p><pre><code class="hljs js"><span class="hljs-string">&#x27;for &gt; for-of &gt; forEach  &gt; map &gt; for-in&#x27;</span></code></pre><ul><li><code>for</code> 循环当然是最简单的，因为它没有任何额外的函数调用栈和上下文；</li><li><code>for...of</code>只要具有 Iterator 接口的数据结构，都可以使用它迭代成员。它直接读取的是键值。</li><li><code>forEach</code>，因为它其实比我们想象得要复杂一些，它实际上是<code>array.forEach(function(currentValue, index, arr), thisValue)</code>它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；</li><li><code>map()</code> 最慢，因为它的返回值是一个等长的全新的数组，数组创建和赋值产生的性能开销很大。</li><li><code>for...in</code>需要穷举对象的所有属性，包括自定义的添加的属性也能遍历到。且<code>for...in</code>的 key 是<code>String</code>类型，有转换过程，开销比较大。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际开发中我们要结合语义话、可读性和程序性能，去选择究竟使用哪种方案。</p><p>如果你需要将数组按照某种规则映射为另一个数组，就应该用 map。</p><p>如果你需要进行简单的遍历，用 forEach 或者 for of。</p><p>如果你需要对迭代器进行遍历，用 for of。</p><p>如果你需要过滤出符合条件的项，用 filter。</p><p>如果你需要先按照规则映射为新数组，再根据条件过滤，那就用一个 map 加一个 filter。</p><p>总之，因地制宜，因时而变。千万不要因为过分追求性能，而忽略了语义和可读性。在实际开发中，让他们扬长避短，优势互补，让程序趋近最优才是我们要做的。</p><p>原文地址 <a href="https://juejin.im/post/5ee6e7c4f265da76e46e6bb7">https://juejin.im/post/5ee6e7c4f265da76e46e6bb7</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gulp升级（3-&gt;4）小记</title>
    <link href="/2020/05/26/webapck/gulp%E5%8D%87%E7%BA%A7%EF%BC%883-%3E4%EF%BC%89%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/05/26/webapck/gulp%E5%8D%87%E7%BA%A7%EF%BC%883-%3E4%EF%BC%89%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="问题1-在执行gulp命令时控制台报错：Task-function-must-be-specified。"><a href="#问题1-在执行gulp命令时控制台报错：Task-function-must-be-specified。" class="headerlink" title="问题1. 在执行gulp命令时控制台报错：Task function must be specified。"></a>问题1. 在执行gulp命令时控制台报错：Task function must be specified。</h4><p>解决方法：</p><p>4.0错误的写法：</p><pre><code class="hljs js">    gulp.task(<span class="hljs-string">&#x27;default&#x27;</span>, [<span class="hljs-string">&#x27;del&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// default task code here</span>&#125;);</code></pre><p>修改为最新的正确写法：</p><pre><code class="hljs js">    gulp.task(<span class="hljs-string">&#x27;default&#x27;</span>, gulp.series(<span class="hljs-string">&#x27;del&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// default task code here</span>&#125;));</code></pre><h4 id="问题2-Gulp-error-The-following-tasks-did-not-complete-Did-you-forget-to-signal-async-completion"><a href="#问题2-Gulp-error-The-following-tasks-did-not-complete-Did-you-forget-to-signal-async-completion" class="headerlink" title="问题2. Gulp error: The following tasks did not complete: Did you forget to signal async completion?"></a>问题2. Gulp error: The following tasks did not complete: Did you forget to signal async completion?</h4><pre><code class="hljs js"><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>);gulp.task(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;HTTP Server Started&quot;</span>);&#125;);</code></pre><p>解决办法：</p><p>1.这种操作方式是用来新建task的，和3.x的用法一样。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> print = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-print&#x27;</span>);gulp.task(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">&#x27;package.json&#x27;</span>)        .pipe(print(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;HTTP Server Started&#x27;</span>; &#125;));&#125;);</code></pre><ol start="2"><li>返回一个Promise 在异步请求机制中，是有一个Promise对象的，它包含了请求的过程中所有内容。如下：</li></ol><pre><code class="hljs js">gulp.task(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;HTTP Server Started&quot;</span>);        resolve();    &#125;);&#125;);</code></pre><ol start="3"><li>返回一个回调函数</li></ol><p>这个是最简单的一种方法，gulp会自动将这个回调函数作为一个参数返回到任务中，在完成的时候一定要调用这个函数。如下：</p><pre><code class="hljs js">gulp.task(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">done</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;HTTP Server Started&quot;</span>);    done();&#125;);</code></pre><ol start="4"><li>返回一个子进程child process</li></ol><p>当我们只是执行一段纯js代码，没有用到node相关的方法时用这个方法</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).spawn;gulp.task(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> spawn(<span class="hljs-string">&#x27;echo&#x27;</span>, [<span class="hljs-string">&#x27;HTTP&#x27;</span>, <span class="hljs-string">&#x27;Server&#x27;</span>, <span class="hljs-string">&#x27;Started&#x27;</span>], &#123;<span class="hljs-attr">stdio</span>: <span class="hljs-string">&#x27;inherit&#x27;</span>&#125;);&#125;);</code></pre><ol start="5"><li>返回一个 RxJS Observable.</li></ol><p>如果你是用RxJS 的时候，可以用这个方法。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> Observable = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;rx&#x27;</span>).Observable;gulp.task(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> o = Observable.just(<span class="hljs-string">&#x27;HTTP Server Started&#x27;</span>);    o.subscribe(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(str);    &#125;);    <span class="hljs-keyword">return</span> o;&#125;);</code></pre><h4 id="问题3-在执行gulp命令时控制台报错：Received-a-non-Vinyl-object-in-dest-。"><a href="#问题3-在执行gulp命令时控制台报错：Received-a-non-Vinyl-object-in-dest-。" class="headerlink" title="问题3. 在执行gulp命令时控制台报错：Received a non-Vinyl object in dest()。"></a>问题3. 在执行gulp命令时控制台报错：Received a non-Vinyl object in <code>dest()</code>。</h4><pre><code class="hljs crmsh">gulp虽然是基于<span class="hljs-keyword">node</span><span class="hljs-title">的，但是它并没有直接使用node</span>中fs模块里的文件系统和流，而是包装了一层vinyl。vinyl是一个用来描述文件的简单的数据格式。所以gulp中的流其实是一种vinyl流，与我们通常所见的流其实不是一种流。</code></pre><p>解决方法： gulp.dest()<br>创建一个用于将 Vinyl 对象写入到文件系统的流 所以vinyl-source-stream必须与gulp4版本保持一致（2.x版本）</p>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
      <tag>gulp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue路由解耦+前端自定义打包</title>
    <link href="/2020/05/15/solutions/%E8%B7%AF%E7%94%B1%E8%A7%A3%E8%80%A6+%E5%89%8D%E7%AB%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8C%85/"/>
    <url>/2020/05/15/solutions/%E8%B7%AF%E7%94%B1%E8%A7%A3%E8%80%A6+%E5%89%8D%E7%AB%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>背景1：同事吐槽vue-router的路由文件维护困难，随着工程越来越大，增减模块费劲。路由文件过大（几千行）。新同事接手难如登天<br>背景2：虽然我们是SPA的项目架构，但是由于是toB业务，后端同学是提供的微服务，可以根据客户的需求<del>买不买得起</del>，而决定为客户部署什么服务。希望前端又同样的能力（<del>别想什么iframe/权限控制，一句多的代码都不想给甲方</del>）</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>webpack提供递归文件夹的能力，轻松解决第一个问题<br>在路由解耦的基础上，通过配置文件，加载不同的router文件。导致webpack组装的依赖不同，达到自定义打包的目的。</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="路由解耦："><a href="#路由解耦：" class="headerlink" title="路由解耦："></a>路由解耦：</h3><pre><code class="hljs js"><span class="hljs-comment">// 读取路由文件，缓存在this.routerList中。</span><span class="hljs-keyword">const</span> routerFiles = <span class="hljs-built_in">require</span>.context(    process.env.NODE_ENV === <span class="hljs-string">&#x27;production&#x27;</span> ? <span class="hljs-string">&#x27;@/bundle-temp&#x27;</span> : <span class="hljs-string">&#x27;@/views&#x27;</span>,<span class="hljs-literal">true</span>, <span class="hljs-regexp">/\.router.js$/</span>);routerFiles.keys().forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;    <span class="hljs-built_in">this</span>.routerList.push(routerFiles(item).default);&#125;);<span class="hljs-comment">// 动态增加页面路由</span><span class="hljs-built_in">this</span>.router.addRoutes(    [...formatRouters(), &#123;<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-attr">redirect</span>: &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;404&#x27;</span>&#125;&#125;]);<span class="hljs-comment">// 路由重复加载处理</span><span class="hljs-keyword">const</span> routerPush = VueRouter.prototype.push;VueRouter.prototype.push = <span class="hljs-function">(<span class="hljs-params">location</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> routerPush.call(<span class="hljs-built_in">this</span>.router, location)    .catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> error);&#125;;<span class="hljs-keyword">const</span> routerReplace = VueRouter.prototype.replace;VueRouter.prototype.replace = <span class="hljs-function">(<span class="hljs-params">location</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> routerReplace.call(<span class="hljs-built_in">this</span>.router, location)    .catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> error);&#125;;<span class="hljs-comment">// 格式化路由配置项</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatRouters</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> result = [];    <span class="hljs-comment">// 按照路由sort从小到大排序，默认sort为0</span>    <span class="hljs-built_in">this</span>.routerList.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(a.sort || <span class="hljs-number">0</span>) - <span class="hljs-built_in">Number</span>(b.sort || <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;    &#125;);    <span class="hljs-built_in">this</span>.routerList.forEach(<span class="hljs-function">(<span class="hljs-params">router</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 如果没有parentName添加到根路由中</span>        <span class="hljs-keyword">if</span> (!router.parentName) &#123;            <span class="hljs-keyword">const</span> hasChildren = <span class="hljs-built_in">this</span>.routerList.some(                (item) =&gt; item.parentName === router.name);            <span class="hljs-keyword">if</span> (hasChildren) &#123;                <span class="hljs-comment">// 有子路由则增加children</span>                <span class="hljs-built_in">Object</span>.defineProperty(router, <span class="hljs-string">&#x27;children&#x27;</span>, &#123;                    value: [],                    writable: <span class="hljs-literal">true</span>                &#125;);                <span class="hljs-built_in">this</span>.formatChildrenRouters(router.children, router);            &#125;            store.commit(<span class="hljs-string">&#x27;addRouterConfig&#x27;</span>, router);            result.push(router);        &#125;    &#125;);    <span class="hljs-keyword">return</span> result;&#125;</code></pre><h3 id="自定义打包："><a href="#自定义打包：" class="headerlink" title="自定义打包："></a>自定义打包：</h3><ol><li>配置package.json<pre><code class="hljs 1c"><span class="hljs-string">&quot;serve&quot;</span>: <span class="hljs-string">&quot;npm run lint&amp;&amp;vue-cli-service serve&quot;</span>,<span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;BUILD_TYPE=all node scripts/bundle/bundle-builder.js&quot;</span>,<span class="hljs-string">&quot;lint&quot;</span>: <span class="hljs-string">&quot;vue-cli-service lint&quot;</span>,<span class="hljs-string">&quot;mock&quot;</span>: <span class="hljs-string">&quot;feMock --dir=mock --port=10195&quot;</span>,<span class="hljs-string">&quot;bundle&quot;</span>: <span class="hljs-string">&quot;npm run lint&amp;&amp;vue-cli-service build&quot;</span></code></pre></li><li>编写打包node脚本<pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">const</span> targetPath = path.resolve(<span class="hljs-string">&#x27;./src/bundle-temp&#x27;</span>);<span class="hljs-keyword">const</span> devRouterPath = path.resolve(<span class="hljs-string">&#x27;./src/views&#x27;</span>);<span class="hljs-keyword">const</span> spawn = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>).spawn;<span class="hljs-keyword">const</span> buildType = process.env.BUILD_TYPE;<span class="hljs-keyword">const</span> routerReg = <span class="hljs-regexp">/\.router.js$/</span>;<span class="hljs-comment">// 基础路由，</span><span class="hljs-keyword">const</span> defaultRouter = [    <span class="hljs-string">&#x27;main.router.js&#x27;</span>,    <span class="hljs-string">&#x27;login.router.js&#x27;</span>,    <span class="hljs-string">&#x27;404.router.js&#x27;</span>];<span class="hljs-keyword">let</span> routerConfig = <span class="hljs-literal">null</span>;<span class="hljs-keyword">if</span> (buildType &amp;&amp; buildType !== <span class="hljs-string">&#x27;all&#x27;</span>) &#123;    <span class="hljs-comment">// 根据type读取对应路由配置</span>    <span class="hljs-keyword">const</span> customRouter = fs.readFileSync(<span class="hljs-string">`./scripts/bundle/<span class="hljs-subst">$&#123;buildType&#125;</span>.json`</span>);    routerConfig = defaultRouter.concat(<span class="hljs-built_in">JSON</span>.parse(customRouter));&#125;fs.exists(targetPath, <span class="hljs-function">(<span class="hljs-params">exists</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (exists) &#123;        <span class="hljs-keyword">const</span> oldPaths = fs.readdirSync(targetPath);        oldPaths.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;            <span class="hljs-keyword">const</span> curPath = <span class="hljs-string">`<span class="hljs-subst">$&#123;targetPath&#125;</span>/<span class="hljs-subst">$&#123;file&#125;</span>`</span>;            <span class="hljs-comment">// 删除文件</span>            fs.unlinkSync(curPath);        &#125;);    &#125; <span class="hljs-keyword">else</span> &#123;        fs.mkdirSync(targetPath);    &#125;    getAllRouters(devRouterPath, routerConfig);    <span class="hljs-comment">// 运行npm脚本并输出执行结果到控制台</span>    <span class="hljs-built_in">console</span>.time();    <span class="hljs-keyword">const</span> handler = spawn(<span class="hljs-string">&#x27;npm&#x27;</span>, [<span class="hljs-string">&#x27;run&#x27;</span>, <span class="hljs-string">&#x27;bundle&#x27;</span>]);    handler.stdout.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(data.toString());    &#125;);    handler.stderr.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(data.toString());    &#125;);    handler.on(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">code</span>) =&gt;</span> &#123;        delFile(targetPath);        <span class="hljs-built_in">console</span>.timeEnd();    &#125;);&#125;);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取所有路由配置</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>dirPath 目标文件夹地址</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>config 可选参数，路由配置数组,如果不传则打包全部路由</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAllRouters</span>(<span class="hljs-params">dirPath, config</span>) </span>&#123;    <span class="hljs-keyword">const</span> viewsPaths = fs.readdirSync(dirPath);    <span class="hljs-keyword">if</span> (viewsPaths &amp;&amp; viewsPaths.length) &#123;        viewsPaths.forEach(<span class="hljs-function">(<span class="hljs-params">filename</span>) =&gt;</span> &#123;            <span class="hljs-keyword">const</span> pathname = path.join(dirPath, filename);            <span class="hljs-keyword">const</span> fileInfo = fs.statSync(pathname);            <span class="hljs-keyword">if</span> (fileInfo.isDirectory()) &#123;                getAllRouters(pathname, config);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fileInfo.isFile()) &#123;                <span class="hljs-keyword">const</span> isRouter = routerReg.test(filename);                <span class="hljs-keyword">if</span> (isRouter) &#123;                    <span class="hljs-keyword">const</span> routerName = filename.replace(routerReg, <span class="hljs-string">&#x27;&#x27;</span>);                    <span class="hljs-keyword">if</span> (!config || config.indexOf(routerName) &gt; <span class="hljs-number">-1</span>) &#123;                        <span class="hljs-keyword">const</span> target = <span class="hljs-string">`<span class="hljs-subst">$&#123;targetPath&#125;</span>/<span class="hljs-subst">$&#123;filename&#125;</span>`</span>;                        fs.writeFileSync(target, fs.readFileSync(pathname));                    &#125;                &#125;            &#125;        &#125;);    &#125;&#125;</code></pre></li><li>指定不同环境下指定不同的获取路由文件的目录：<pre><code class="hljs ini"><span class="hljs-attr">process.env.NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span> ? <span class="hljs-string">&#x27;@/bundle-temp&#x27;</span> : <span class="hljs-string">&#x27;@/views&#x27;</span>,</code></pre></li><li>编写配置文件，根据配置文件生成打包文件目录<pre><code class="hljs json">[    <span class="hljs-string">&quot;example&quot;</span>,    <span class="hljs-string">&quot;grid-example&quot;</span>,    <span class="hljs-string">&quot;echarts-example&quot;</span>,    <span class="hljs-string">&quot;example-canvas&quot;</span>,    <span class="hljs-string">&quot;example-no-group&quot;</span>,    <span class="hljs-string">&quot;draw-area-example&quot;</span>,    <span class="hljs-string">&quot;flow-chart&quot;</span>]</code></pre></li><li>webpack根据路由文件组装依赖</li><li>打包完成后删除临时文件夹<pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 构建完成后删除临时文件夹</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;*&#125;</span> </span>path 必传参数可以是文件夹可以是文件</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delFile</span>(<span class="hljs-params">path</span>) </span>&#123;    <span class="hljs-keyword">if</span> (fs.existsSync(path)) &#123;        <span class="hljs-keyword">if</span> (fs.statSync(path).isDirectory()) &#123;            <span class="hljs-keyword">let</span> files = fs.readdirSync(path);            files.forEach(<span class="hljs-function">(<span class="hljs-params">file, index</span>) =&gt;</span> &#123;                <span class="hljs-keyword">let</span> currentPath = path + <span class="hljs-string">&#x27;/&#x27;</span> + file;                <span class="hljs-keyword">if</span> (fs.statSync(currentPath).isDirectory()) &#123;                    delFile(currentPath);                &#125; <span class="hljs-keyword">else</span> &#123;                    fs.unlinkSync(currentPath);                &#125;            &#125;);            fs.rmdirSync(path);        &#125; <span class="hljs-keyword">else</span> &#123;            fs.unlinkSync(path);        &#125;    &#125;&#125;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>工作杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack动态懒加载</title>
    <link href="/2020/04/24/webapck/webpack%E5%8A%A8%E6%80%81%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2020/04/24/webapck/webpack%E5%8A%A8%E6%80%81%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>起因是因为一个基于 vue-cli3.0 的项目突然反馈 vendor 包过大，为了减少用户的白屏时间开始做优化。</p><a id="more"></a><hr><h4 id="webpack4-的-splitChunk-插件"><a href="#webpack4-的-splitChunk-插件" class="headerlink" title="webpack4 的 splitChunk 插件"></a>webpack4 的 splitChunk 插件</h4><p>用过 vue-cli3.0 的同学应该熟悉，其舍弃了以前常用的 build 文件夹下的<code>webpack.config.js</code>文件配置，配置内容全部放到<code>vue.config.js</code>文件中，实际上关于 webpack 的配置其实和之前大同小异。打包拆分不得不聊到常用的<code>CommonsChunkPlugin</code>。</p><p>旧项目常用的方式就是通过<code>webpack.optimize.CommonsChunkPlugin(opts)</code>，加载该插件进行代码分割。但是其存在很多问题：</p><ul><li>它可能导致下载更多的超过我们使用的代码</li><li>它在异步 chunks 中是低效的</li><li>配置繁琐，很难使用</li><li>难以被理解</li></ul><p>在 webpack4 抛弃了<code>CommonsChunkPlugin</code>，换成了更先进的<code>SplitChunksPlugin</code>。它们的区别就在于，<code>CommonChunksPlugin</code> 会找到多数模块中都共有的东西，并且把它提取出来（common.js），也就意味着如果你加载了 common.js，那么里面可能会存在一些当前模块不需要的东西。</p><p>而 <code>SplitChunksPlugin</code> 采用了完全不同的 heuristics 方法，它会根据模块之间的依赖关系，自动打包出很多很多（而不是单个）通用模块，可以保证加载进来的代码一定是会被依赖到的。</p><p>下面是一个简单的例子，假设我们有 4 个 chunk，分别依赖了以下模块：</p><p><img src="/images/pages/webplan1.png" alt="image"></p><p>根据<code>CommonChunksPlugin</code>的默认配置，会打包成：  </p><p><img src="/images/pages/webplan2.png" alt="image"></p><p>而<code>SplitChunksPlugin</code>会打包成：  </p><p><img src="/images/pages/webplan3.png" alt="image"></p><p>显然进一步优化了空间。</p><p>当然这不是本次讨论的重点，因为 vue-cli3.0 默认情况下已经是使用了<code>SplitChunksPlugin</code>的配置，查看 vue-cli service config 文件夹下的 app.js，有一段链式的 webpackConfig 配置了最终打包的 chunks 配置。</p><pre><code class="hljs js"><span class="hljs-keyword">if</span> (isProd &amp;&amp; !process.env.CYPRESS_ENV) &#123;  webpackConfig    .optimization.splitChunks(&#123;      cacheGroups: &#123;        vendors: &#123;          name: <span class="hljs-string">`chunk-vendors`</span>,          test: <span class="hljs-regexp">/[\\/]node_modules[\\/]/</span>,          priority: <span class="hljs-number">-10</span>,          chunks: <span class="hljs-string">&#x27;initial&#x27;</span>        &#125;,        common: &#123;          name: <span class="hljs-string">`chunk-common`</span>,          minChunks: <span class="hljs-number">2</span>,          priority: <span class="hljs-number">-20</span>,          chunks: <span class="hljs-string">&#x27;initial&#x27;</span>,          reuseExistingChunk: <span class="hljs-literal">true</span>        &#125;      &#125;    &#125;)&#125;</code></pre><p>通常该默认情况可以满足大部分应用场景，但是考虑我们项目的特殊性，我需要额外提高<code>chunk-vendors</code>的 minChunks 项，让一些偶尔出现但是频率没有太高的依赖滚出 vendors。</p><hr><h4 id="动态懒加载"><a href="#动态懒加载" class="headerlink" title="动态懒加载"></a>动态懒加载</h4><p>先来聊聊 import 和 require 的区别。<br>require/exports 出生在野生规范当中，什么叫做野生规范？即这些规范是 JavaScript 社区中的开发者自己草拟的规则，得到了大家的承认或者广泛的应用。比如 CommonJS、AMD、CMD 等等。<br>import/export 则是名门正派。TC39 制定的新的 ECMAScript 版本，即 ES6（ES2015）中包含进来。</p><p><code>const PAGE_A = require.ensure([], () =&gt; &#123;require(&quot;a&quot;)&#125;</code>。早期写 vue-router，习惯以这种形式去完成异步加载。后续日常开发中，常用的就是 import from 来引入资源（千万避免全局引入 ui 组件，可能会导致资源包异常的大）webpack 官方就指出，应该用 import 来代替<code>require.ensure</code></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">determineDate</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moment&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">moment</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(moment().format());  &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Failed to load moment&#x27;</span>, err);  &#125;);&#125;<span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./component&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">Component</span> =&gt;</span> &#123;    <span class="hljs-comment">// ....</span>&#125;);<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">determineDate</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> moment = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moment&#x27;</span>);  <span class="hljs-keyword">return</span> moment().format(<span class="hljs-string">&#x27;LLLL&#x27;</span>);&#125;determineDate().then(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(str));</code></pre><p>相比较而言，import 使用了 promise 的封装，只接受一个参数，就是引用包的地址，语法十分简单。</p><p>由于 webpack 需要将所有 import() 的模块都进行单独打包，所以在工程打包阶段，webpack 会进行依赖收集。webpack 会找到所有 import() 的调用，将传入的参数处理成一个正则，如：</p><pre><code class="hljs js"><span class="hljs-comment">// import(&#x27;./app&#x27;+path+&#x27;/util&#x27;) =&gt; /^\.\/app.*\/util$/</span></code></pre><p>也就是说，import 参数中的所有变量，都会被替换为【.*】，而 webpack 就根据这个正则，查找所有符合条件的包，将其作为 package 进行打包。<br>所以 import 的正确姿势，应该是<strong>尽可能静态化表达包所处的路径，最小化变量控制的区域。</strong><br>如我们要引用一堆页面组件，可以使用<code>import(&#39;./pages/&#39;+ComponentName)</code>，这样就可以实现引用的封装，同时也避免打包多余的内容。但是 webpack 会保证该路径下所有可能引入的文件是可用的，即会预请求。</p><p>官方指出，在 import 内部添加注释，可以完成 chunkname 命名、打包模式等功能。4.6 + 还支持 Prefetching/Preloading 来提前加载 / 预加载资源。（prefetch 用于未来会发生的场合，preload 用于当前场合）</p><pre><code class="hljs js"><span class="hljs-keyword">import</span>(      <span class="hljs-string">&#x27;module&#x27;</span>);<span class="hljs-keyword">import</span>(              <span class="hljs-string">`./locale/<span class="hljs-subst">$&#123;language&#125;</span>`</span>);</code></pre><p>的确是可以完美取代 require 了</p><hr><h4 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h4><p>借助<code>webpack-bundle-analyzer</code>，可以清晰的查看，打包后之后项目的文件大小以及其构成。对于做性能优化有很大的帮助。具体使用方法不再详述，建议直接移步<a href="https://links.jianshu.com/go?to=https://www.npmjs.com/package/webpack-bundle-analyzer">官方文档</a>。</p><hr><h4 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h4><p>其实大部分是关于 webpack 的使用方式。老的 require.ensure 也好，新的 import 也好，其实本质还是交给 webpack 去打包处理，在最后选择如何去引入。<br>重要的是 webpack 的配置，即便用了 vue-cli3.0 依然要考虑自定义配置如何去完成，再细化一点就是 import 的引入方式。</p><hr><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://links.jianshu.com/go?to=https://juejin.im/post/5af1677c6fb9a07ab508dabb">一步一步的了解 webpack4 的 splitChunk 插件</a><br><a href="https://links.jianshu.com/go?to=https://www.zhihu.com/question/56820346">require 和 import 的区别</a><br><a href="https://links.jianshu.com/go?to=https://segmentfault.com/a/1190000015648036">webpack import() 动态加载模块踩坑</a><br><a href="https://links.jianshu.com/go?to=https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a></p><p>原文地址 <a href="https://www.jianshu.com/p/54015bf76047">https://www.jianshu.com/p/54015bf76047</a></p>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack配置小记</title>
    <link href="/2020/04/17/webapck/webpack%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/04/17/webapck/webpack%E9%85%8D%E7%BD%AE%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="多入口配置"><a href="#多入口配置" class="headerlink" title="多入口配置"></a>多入口配置</h2><a id="more"></a><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<span class="hljs-keyword">const</span> &#123; srcPath, distPath &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./paths&#x27;</span>)<span class="hljs-built_in">module</span>.exports = &#123;    entry: &#123;        index: path.join(srcPath, <span class="hljs-string">&#x27;index.js&#x27;</span>),        other: path.join(srcPath, <span class="hljs-string">&#x27;other.js&#x27;</span>)    &#125;,    <span class="hljs-built_in">module</span>: &#123;        rules: [            &#123;                test: <span class="hljs-regexp">/\.js$/</span>,                loader: [<span class="hljs-string">&#x27;babel-loader&#x27;</span>],                include: srcPath,                exclude: <span class="hljs-regexp">/node_modules/</span>            &#125;,            <span class="hljs-comment">// &#123;</span>            <span class="hljs-comment">//     test: /\.css$/,</span>            <span class="hljs-comment">//     // loader 的执行顺序是：从后往前</span>            <span class="hljs-comment">//     loader: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]</span>            <span class="hljs-comment">// &#125;,</span>            &#123;                test: <span class="hljs-regexp">/\.css$/</span>,                <span class="hljs-comment">// loader 的执行顺序是：从后往前</span>                loader: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>] <span class="hljs-comment">// 加了 postcss</span>            &#125;,            &#123;                test: <span class="hljs-regexp">/\.less$/</span>,                <span class="hljs-comment">// 增加 &#x27;less-loader&#x27; ，注意顺序</span>                loader: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;less-loader&#x27;</span>]            &#125;        ]    &#125;,    plugins: [        <span class="hljs-comment">// new HtmlWebpackPlugin(&#123;</span>        <span class="hljs-comment">//     template: path.join(srcPath, &#x27;index.html&#x27;),</span>        <span class="hljs-comment">//     filename: &#x27;index.html&#x27;</span>        <span class="hljs-comment">// &#125;)</span>        <span class="hljs-comment">// 多入口 - 生成 index.html</span>        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;            template: path.join(srcPath, <span class="hljs-string">&#x27;index.html&#x27;</span>),            filename: <span class="hljs-string">&#x27;index.html&#x27;</span>,            <span class="hljs-comment">// chunks 表示该页面要引用哪些 chunk （即上面的 index 和 other），默认全部引用</span>            chunks: [<span class="hljs-string">&#x27;index&#x27;</span>]  <span class="hljs-comment">// 只引用 index.js</span>        &#125;),        <span class="hljs-comment">// 多入口 - 生成 other.html</span>        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;            template: path.join(srcPath, <span class="hljs-string">&#x27;other.html&#x27;</span>),            filename: <span class="hljs-string">&#x27;other.html&#x27;</span>,            chunks: [<span class="hljs-string">&#x27;other&#x27;</span>]  <span class="hljs-comment">// 只引用 other.js</span>        &#125;)    ]&#125;</code></pre><h2 id="CSS压缩"><a href="#CSS压缩" class="headerlink" title="CSS压缩"></a>CSS压缩</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<span class="hljs-keyword">const</span> &#123; smart &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>)<span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>)<span class="hljs-keyword">const</span> TerserJSPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>)<span class="hljs-keyword">const</span> OptimizeCSSAssetsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)<span class="hljs-keyword">const</span> webpackCommonConf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>)<span class="hljs-keyword">const</span> &#123; srcPath, distPath &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./paths&#x27;</span>)  <span class="hljs-built_in">module</span>.exports = smart(webpackCommonConf, &#123;    mode: <span class="hljs-string">&#x27;production&#x27;</span>,    output: &#123;        <span class="hljs-comment">// filename: &#x27;bundle.[contentHash:8].js&#x27;,  // 打包代码时，加上 hash 戳</span>        filename: <span class="hljs-string">&#x27;[name].[contentHash:8].js&#x27;</span>, <span class="hljs-comment">// name 即多入口时 entry 的 key</span>        path: distPath,        <span class="hljs-comment">// publicPath: &#x27;http://cdn.abc.com&#x27;  // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到</span>    &#125;,    <span class="hljs-built_in">module</span>: &#123;        rules: [            <span class="hljs-comment">// 图片 - 考虑 base64 编码的情况</span>            &#123;                test: <span class="hljs-regexp">/\.(png|jpg|jpeg|gif)$/</span>,                use: &#123;                    loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,                    options: &#123;                        <span class="hljs-comment">// 小于 5kb 的图片用 base64 格式产出</span>                        <span class="hljs-comment">// 否则，依然延用 file-loader 的形式，产出 url 格式</span>                        limit: <span class="hljs-number">5</span> * <span class="hljs-number">1024</span>,                        <span class="hljs-comment">// 打包到 img 目录下</span>                        outputPath: <span class="hljs-string">&#x27;/img1/&#x27;</span>,                        <span class="hljs-comment">// 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源）</span>                        <span class="hljs-comment">// publicPath: &#x27;http://cdn.abc.com&#x27;</span>                    &#125;                &#125;            &#125;,            <span class="hljs-comment">// 抽离 css</span>            &#123;                test: <span class="hljs-regexp">/\.css$/</span>,                loader: [                    MiniCssExtractPlugin.loader,  <span class="hljs-comment">// 注意，这里不再用 style-loader</span>                    <span class="hljs-string">&#x27;css-loader&#x27;</span>,                    <span class="hljs-string">&#x27;postcss-loader&#x27;</span>                ]            &#125;,            <span class="hljs-comment">// 抽离 less --&gt; css</span>            &#123;                test: <span class="hljs-regexp">/\.less$/</span>,                loader: [                    MiniCssExtractPlugin.loader,  <span class="hljs-comment">// 注意，这里不再用 style-loader</span>                    <span class="hljs-string">&#x27;css-loader&#x27;</span>,                    <span class="hljs-string">&#x27;less-loader&#x27;</span>,                    <span class="hljs-string">&#x27;postcss-loader&#x27;</span>                ]            &#125;        ]    &#125;,    plugins: [        <span class="hljs-keyword">new</span> CleanWebpackPlugin(), <span class="hljs-comment">// 会默认清空 output.path 文件夹</span>        <span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;            <span class="hljs-comment">// window.ENV = &#x27;production&#x27;</span>            ENV: <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;production&#x27;</span>)        &#125;),        <span class="hljs-comment">// 抽离 css 文件</span>        <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;            filename: <span class="hljs-string">&#x27;css/main.[contentHash:8].css&#x27;</span>        &#125;)    ],    optimization: &#123;        <span class="hljs-comment">// 压缩 css</span>        minimizer: [<span class="hljs-keyword">new</span> TerserJSPlugin(&#123;&#125;), <span class="hljs-keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)],    &#125;&#125;)</code></pre><h2 id="抽离公共代码"><a href="#抽离公共代码" class="headerlink" title="抽离公共代码"></a>抽离公共代码</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<span class="hljs-keyword">const</span> &#123; smart &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-merge&#x27;</span>)<span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mini-css-extract-plugin&#x27;</span>)<span class="hljs-keyword">const</span> TerserJSPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;terser-webpack-plugin&#x27;</span>)<span class="hljs-keyword">const</span> OptimizeCSSAssetsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;optimize-css-assets-webpack-plugin&#x27;</span>)<span class="hljs-keyword">const</span> webpackCommonConf = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./webpack.common.js&#x27;</span>)<span class="hljs-keyword">const</span> &#123; srcPath, distPath &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./paths&#x27;</span>)<span class="hljs-built_in">module</span>.exports = smart(webpackCommonConf, &#123;    mode: <span class="hljs-string">&#x27;production&#x27;</span>,    output: &#123;        <span class="hljs-comment">// filename: &#x27;bundle.[contentHash:8].js&#x27;,  // 打包代码时，加上 hash 戳</span>        filename: <span class="hljs-string">&#x27;[name].[contentHash:8].js&#x27;</span>, <span class="hljs-comment">// name 即多入口时 entry 的 key</span>        path: distPath,        <span class="hljs-comment">// publicPath: &#x27;http://cdn.abc.com&#x27;  // 修改所有静态文件 url 的前缀（如 cdn 域名），这里暂时用不到</span>    &#125;,    <span class="hljs-built_in">module</span>: &#123;        rules: [            <span class="hljs-comment">// 图片 - 考虑 base64 编码的情况</span>            &#123;                test: <span class="hljs-regexp">/\.(png|jpg|jpeg|gif)$/</span>,                use: &#123;                    loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,                    options: &#123;                        <span class="hljs-comment">// 小于 5kb 的图片用 base64 格式产出</span>                        <span class="hljs-comment">// 否则，依然延用 file-loader 的形式，产出 url 格式</span>                        limit: <span class="hljs-number">5</span> * <span class="hljs-number">1024</span>,                        <span class="hljs-comment">// 打包到 img 目录下</span>                        outputPath: <span class="hljs-string">&#x27;/img1/&#x27;</span>,                        <span class="hljs-comment">// 设置图片的 cdn 地址（也可以统一在外面的 output 中设置，那将作用于所有静态资源）</span>                        <span class="hljs-comment">// publicPath: &#x27;http://cdn.abc.com&#x27;</span>                    &#125;                &#125;            &#125;,            <span class="hljs-comment">// 抽离 css</span>            &#123;                test: <span class="hljs-regexp">/\.css$/</span>,                loader: [                    MiniCssExtractPlugin.loader,  <span class="hljs-comment">// 注意，这里不再用 style-loader</span>                    <span class="hljs-string">&#x27;css-loader&#x27;</span>,                    <span class="hljs-string">&#x27;postcss-loader&#x27;</span>                ]            &#125;,            <span class="hljs-comment">// 抽离 less</span>            &#123;                test: <span class="hljs-regexp">/\.less$/</span>,                loader: [                    MiniCssExtractPlugin.loader,  <span class="hljs-comment">// 注意，这里不再用 style-loader</span>                    <span class="hljs-string">&#x27;css-loader&#x27;</span>,                    <span class="hljs-string">&#x27;less-loader&#x27;</span>,                    <span class="hljs-string">&#x27;postcss-loader&#x27;</span>                ]            &#125;        ]    &#125;,    plugins: [        <span class="hljs-keyword">new</span> CleanWebpackPlugin(), <span class="hljs-comment">// 会默认清空 output.path 文件夹</span>        <span class="hljs-keyword">new</span> webpack.DefinePlugin(&#123;            <span class="hljs-comment">// window.ENV = &#x27;production&#x27;</span>            ENV: <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;production&#x27;</span>)        &#125;),        <span class="hljs-comment">// 抽离 css 文件</span>        <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;            filename: <span class="hljs-string">&#x27;css/main.[contentHash:8].css&#x27;</span>        &#125;)    ],    optimization: &#123;        <span class="hljs-comment">// 压缩 css</span>        minimizer: [<span class="hljs-keyword">new</span> TerserJSPlugin(&#123;&#125;), <span class="hljs-keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)],        <span class="hljs-comment">// 分割代码块</span>        splitChunks: &#123;            chunks: <span class="hljs-string">&#x27;all&#x27;</span>,            <span class="hljs-comment">/**</span><span class="hljs-comment">             * initial 入口 chunk，对于异步导入的文件不处理</span><span class="hljs-comment">                async 异步 chunk，只对异步导入的文件处理</span><span class="hljs-comment">                all 全部 chunk</span><span class="hljs-comment">             */</span>            <span class="hljs-comment">// 缓存分组</span>            cacheGroups: &#123;                <span class="hljs-comment">// 第三方模块</span>                vendor: &#123;                    name: <span class="hljs-string">&#x27;vendor&#x27;</span>, <span class="hljs-comment">// chunk 名称</span>                    priority: <span class="hljs-number">1</span>, <span class="hljs-comment">// 权限更高，优先抽离，重要！！！</span>                    test: <span class="hljs-regexp">/node_modules/</span>,                    minSize: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 大小限制</span>                    minChunks: <span class="hljs-number">1</span>  <span class="hljs-comment">// 最少复用过几次</span>                &#125;,                <span class="hljs-comment">// 公共的模块</span>                common: &#123;                    name: <span class="hljs-string">&#x27;common&#x27;</span>, <span class="hljs-comment">// chunk 名称</span>                    priority: <span class="hljs-number">0</span>, <span class="hljs-comment">// 优先级</span>                    minSize: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 公共模块的大小限制</span>                    minChunks: <span class="hljs-number">2</span>  <span class="hljs-comment">// 公共模块最少复用过几次</span>                &#125;            &#125;        &#125;    &#125;&#125;)</code></pre><h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@file <span class="hljs-variable">vue</span></span>-cli4基础配置</span><span class="hljs-comment"> * 配置参考: https://cli.vuejs.org/zh/config/</span><span class="hljs-comment"> */</span><span class="hljs-meta">&#x27;use strict&#x27;</span>;<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<span class="hljs-keyword">const</span> FilterWarningsPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-filter-warnings-plugin&#x27;</span>);<span class="hljs-keyword">const</span> StyleLintPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;stylelint-webpack-plugin&#x27;</span>);<span class="hljs-keyword">const</span> assetsPath = <span class="hljs-function"><span class="hljs-params">assetsPath</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> path.posix.join(<span class="hljs-string">&#x27;static&#x27;</span>, assetsPath);&#125;;<span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">dir</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> path.join(__dirname, dir);&#125;;<span class="hljs-built_in">module</span>.exports = &#123;    publicPath: <span class="hljs-string">&#x27;/&#x27;</span>,    chainWebpack: <span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;        <span class="hljs-comment">// px自动转换为rem</span>        config.module        .rule(<span class="hljs-string">&#x27;less&#x27;</span>)        .test(<span class="hljs-regexp">/\.less$/</span>)        .oneOf(<span class="hljs-string">&#x27;vue&#x27;</span>)        .use(<span class="hljs-string">&#x27;px2rem-loader&#x27;</span>)        .loader(<span class="hljs-string">&#x27;px2rem-loader&#x27;</span>)        .before(<span class="hljs-string">&#x27;postcss-loader&#x27;</span>)        .options(&#123;<span class="hljs-attr">remUnit</span>: <span class="hljs-number">16</span>, <span class="hljs-attr">remPrecision</span>: <span class="hljs-number">8</span>&#125;)        .end();        <span class="hljs-comment">// svg-loader</span>        <span class="hljs-keyword">const</span> svgRule = config.module.rule(<span class="hljs-string">&#x27;svg&#x27;</span>);        svgRule.uses.clear();        svgRule        .test(<span class="hljs-regexp">/\.(svg)(\?.*)?$/</span>)        .use(<span class="hljs-string">&#x27;url-loader&#x27;</span>)        .loader(<span class="hljs-string">&#x27;url-loader&#x27;</span>)        .options(&#123;            limit: <span class="hljs-number">4096</span>,            name: assetsPath(<span class="hljs-string">&#x27;img/[name].[hash:7].[ext]&#x27;</span>)        &#125;)        .end();        <span class="hljs-comment">// moment引入（繁简英）语言包；</span>        config        .plugin(<span class="hljs-string">&#x27;context-replacement&#x27;</span>)        .use(webpack.ContextReplacementPlugin, [            /moment[\\\/]locale$/,            /^\.\/(zh-cn|en|zh-tw)$/        ]);        <span class="hljs-comment">// 去除CSS顺序造成的提示信息</span>        config.plugin(<span class="hljs-string">&#x27;filter-warnings&#x27;</span>).use(FilterWarningsPlugin, [            &#123;                exclude: <span class="hljs-regexp">/mini-css-extract-plugin[^]*Conflicting order between:/</span>            &#125;        ]);        <span class="hljs-comment">// 样式表校验</span>        config.plugin(<span class="hljs-string">&#x27;style-lint&#x27;</span>).use(StyleLintPlugin, [            &#123;                files: [<span class="hljs-string">&#x27;src/**/*.&#123;vue,html,css,less&#125;&#x27;</span>],                fix: <span class="hljs-literal">true</span>            &#125;        ]);        <span class="hljs-comment">// 全局变量配置</span>        <span class="hljs-comment">/*config.plugin(&#x27;provide-plugin&#x27;).use(webpack.ProvidePlugin, [</span><span class="hljs-comment">            &#123;</span><span class="hljs-comment">                Hls: &#x27;hls&#x27;</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">        ]);*/</span>        <span class="hljs-comment">// 设置页面基础配置</span>        config.plugin(<span class="hljs-string">&#x27;html&#x27;</span>).tap(<span class="hljs-function"><span class="hljs-params">args</span> =&gt;</span> &#123;            args[<span class="hljs-number">0</span>].title = <span class="hljs-string">&#x27;BAIDU-CVS&#x27;</span>;            args[<span class="hljs-number">0</span>].meta = &#123;                keywords: <span class="hljs-string">&#x27;BAIDU-CVS&#x27;</span>,                description: <span class="hljs-string">&#x27;BAIDU-CVS&#x27;</span>            &#125;;            <span class="hljs-keyword">return</span> args;        &#125;);    &#125;,    outputDir: <span class="hljs-string">&#x27;./dist&#x27;</span>,    assetsDir: <span class="hljs-string">&#x27;static&#x27;</span>,    css: &#123;        loaderOptions: &#123;            less: &#123;                lessOptions: &#123;                    modifyVars: &#123;                        <span class="hljs-string">&#x27;primary-color&#x27;</span>: <span class="hljs-string">&#x27;#3B48FA&#x27;</span>,                        <span class="hljs-string">&#x27;border-radius-base&#x27;</span>: <span class="hljs-string">&#x27;4px&#x27;</span>,                        <span class="hljs-string">&#x27;layout-body-background&#x27;</span>: <span class="hljs-string">&#x27;#FAFAFC&#x27;</span>,                        <span class="hljs-string">&#x27;layout-sider-background&#x27;</span>: <span class="hljs-string">&#x27;#0C2146&#x27;</span>,                        <span class="hljs-string">&#x27;label-color&#x27;</span>: <span class="hljs-string">&#x27;fade(#0C2146, 85%)&#x27;</span>,                        <span class="hljs-string">&#x27;font-size-base&#x27;</span>: <span class="hljs-string">&#x27;0.875rem&#x27;</span>,                        <span class="hljs-string">&#x27;font-size-lg&#x27;</span>: <span class="hljs-string">&#x27;1rem&#x27;</span>,                        <span class="hljs-string">&#x27;font-size-sm&#x27;</span>: <span class="hljs-string">&#x27;0.75rem&#x27;</span>,                        <span class="hljs-string">&#x27;text-color&#x27;</span>: <span class="hljs-string">&#x27;fade(#0C2146, 65%)&#x27;</span>,                        <span class="hljs-string">&#x27;text-color-dark&#x27;</span>: <span class="hljs-string">&#x27;fade(#0C2146, 85%)&#x27;</span>,                        <span class="hljs-string">&#x27;input-placeholder-color&#x27;</span>: <span class="hljs-string">&#x27;fade(#0C2146, 25%)&#x27;</span>,                        <span class="hljs-string">&#x27;border-color-base&#x27;</span>: <span class="hljs-string">&#x27;#EDEEF1&#x27;</span>,                        <span class="hljs-string">&#x27;menu-dark-bg&#x27;</span>: <span class="hljs-string">&#x27;#0C2146&#x27;</span>,                        <span class="hljs-string">&#x27;menu-dark-item-active-bg&#x27;</span>: <span class="hljs-string">&#x27;#0C2146&#x27;</span>,                        <span class="hljs-string">&#x27;menu-dark-color&#x27;</span>: <span class="hljs-string">&#x27;fade(#fff, 60%)&#x27;</span>,                        <span class="hljs-string">&#x27;modal-mask-bg&#x27;</span>: <span class="hljs-string">&#x27;fade(#0C2146, 50%)&#x27;</span>,                        <span class="hljs-string">&#x27;menu-dark-submenu-bg&#x27;</span>: <span class="hljs-string">&#x27;#091a37&#x27;</span>,                        <span class="hljs-string">&#x27;modal-heading-color&#x27;</span>: <span class="hljs-string">&#x27;fade(#0C2146, 85%)&#x27;</span>                    &#125;,                    javascriptEnabled: <span class="hljs-literal">true</span>                &#125;            &#125;        &#125;    &#125;,    configureWebpack: &#123;        resolve: &#123;            alias: &#123;                <span class="hljs-string">&#x27;@&#x27;</span>: resolve(<span class="hljs-string">&#x27;src&#x27;</span>),                vue$: <span class="hljs-string">&#x27;vue/dist/vue.esm.js&#x27;</span>                <span class="hljs-comment">// hls: path.resolve(__dirname, &#x27;public/flash/hls.min.js&#x27;)</span>            &#125;        &#125;,        <span class="hljs-built_in">module</span>: &#123;            noParse: <span class="hljs-regexp">/^(vue|vue-router|vuex|vuex-router-sync|lodash|moment)$/</span>        &#125;,        <span class="hljs-comment">// 警告 webpack 的性能提示</span>        performance: &#123;            hints: <span class="hljs-string">&#x27;warning&#x27;</span>,            <span class="hljs-comment">// 入口起点的最大体积</span>            maxEntrypointSize: <span class="hljs-literal">Infinity</span>,            <span class="hljs-comment">// 生成文件的最大体积</span>            maxAssetSize:                process.env.NODE_ENV === <span class="hljs-string">&#x27;production&#x27;</span>                    ? <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> <span class="hljs-comment">// 2.0M</span>                    : <span class="hljs-literal">Infinity</span>,            <span class="hljs-comment">// 只给出 js 文件的性能提示</span>            assetFilter: <span class="hljs-function"><span class="hljs-params">assetFilename</span> =&gt;</span> &#123;                <span class="hljs-keyword">return</span> assetFilename.endsWith(<span class="hljs-string">&#x27;.js&#x27;</span>);            &#125;        &#125;,        optimization: &#123;            runtimeChunk: &#123;                name: <span class="hljs-string">&#x27;manifest&#x27;</span>            &#125;,            splitChunks: &#123;                chunks: <span class="hljs-string">&#x27;initial&#x27;</span>,                cacheGroups: &#123;                    <span class="hljs-string">&#x27;ant-design-vue&#x27;</span>: &#123;                        name: <span class="hljs-string">&#x27;ant-design-vue&#x27;</span>,                        test: <span class="hljs-regexp">/ant-design-vue[\\\/]/</span>,                        priority: <span class="hljs-number">10</span>,                        chunks: <span class="hljs-string">&#x27;initial&#x27;</span>                    &#125;,                    <span class="hljs-string">&#x27;antv-g6&#x27;</span>: &#123;                        name: <span class="hljs-string">&#x27;antv-g6&#x27;</span>,                        test: <span class="hljs-regexp">/@antv[\\\/]g6[\\\/]/</span>,                        priority: <span class="hljs-number">8</span>,                        chunks: <span class="hljs-string">&#x27;all&#x27;</span>                    &#125;,                    echarts: &#123;                        name: <span class="hljs-string">&#x27;echarts&#x27;</span>,                        test: <span class="hljs-regexp">/echarts[\\\/]/</span>,                        priority: <span class="hljs-number">6</span>,                        chunks: <span class="hljs-string">&#x27;all&#x27;</span>                    &#125;,                    swiper: &#123;                        name: <span class="hljs-string">&#x27;swiper&#x27;</span>,                        test: <span class="hljs-regexp">/swiper[\\\/]/</span>,                        priority: <span class="hljs-number">4</span>,                        chunks: <span class="hljs-string">&#x27;initial&#x27;</span>                    &#125;,                    vendors: &#123;                        name: <span class="hljs-string">&#x27;vendors&#x27;</span>,                        test: <span class="hljs-regexp">/[\\\/]node_modules[\\\/]/</span>,                        priority: <span class="hljs-number">0</span>,                        chunks: <span class="hljs-string">&#x27;initial&#x27;</span>                    &#125;                &#125;            &#125;        &#125;    &#125;,    productionSourceMap: <span class="hljs-literal">false</span>,    devServer: &#123;        proxy:&#123;            <span class="hljs-comment">// ...</span>        &#125;,        open: <span class="hljs-literal">true</span>,        hot: <span class="hljs-literal">true</span>,        port: <span class="hljs-string">&#x27;****&#x27;</span>,        overlay: &#123;            errors: <span class="hljs-literal">true</span>,            warnings: <span class="hljs-literal">true</span>        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6中的Proxy、Reflect以及Vue3.0中的应用原理</title>
    <link href="/2020/04/02/basic/ES6%E4%B8%AD%E7%9A%84Proxy%E3%80%81Reflect%E4%BB%A5%E5%8F%8AVue3.0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%8E%9F%E7%90%86/"/>
    <url>/2020/04/02/basic/ES6%E4%B8%AD%E7%9A%84Proxy%E3%80%81Reflect%E4%BB%A5%E5%8F%8AVue3.0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="使用Object-defineProperty的一些劣势："><a href="#使用Object-defineProperty的一些劣势：" class="headerlink" title="使用Object.defineProperty的一些劣势："></a>使用<code>Object.defineProperty</code>的一些劣势：</h2><ol><li><code>Object.defineProperty</code>监听的是对象的属性，如果对象比较复杂，需要逐个深层遍历他的属性来实现监听，耗费性能</li><li><code>Object.defineProperty</code>无法监听数组的变化，使 Vue 不得不对数组做了额外的 hack。</li></ol><p>相比之下<code>Proxy</code>就更强大，接下来我们就来了解他。</p><a id="more"></a><p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN-Proxy</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">MDN-Reflect</a></li><li><a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf#heading-3">面试官: 实现双向绑定 Proxy 比 defineproperty 优劣如何?</a></li></ul><h2 id="Proxy-简介"><a href="#Proxy-简介" class="headerlink" title="Proxy 简介"></a>Proxy 简介</h2><p>MDN 上是这么描述的——Proxy对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p><p>官方的描述总是言简意赅，以至于不明觉厉…</p><p>其实就是在对目标对象的操作之前提供了拦截，可以对外界的操作进行过滤和改写，修改某些操作的默认行为，这样我们可以不直接操作对象本身，而是通过操作对象的代理对象来间接来操作对象，达到预期的目的~</p><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。使用方法如下：</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">// 语法</span><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);<span class="hljs-comment">// 用例</span><span class="hljs-keyword">let</span> p = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;<span class="hljs-keyword">let</span> proxyP = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(p, &#123;get() &#123;<span class="hljs-comment">// 获取proxyP对象属性时的自定义逻辑</span>&#125;,set() &#123;<span class="hljs-comment">// 设置proxyP对象属性时的自定义逻辑</span>&#125;&#125;)</code></pre><p>上边的代码中：</p><ul><li>target：用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li><li>handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。</li><li>p/proxyP：是一个被代理后的新对象, 它拥有 target 的一切属性和方法. 只不过其行为和结果是在 handler 中自定义的.</li></ul><blockquote><p>这里重点说一下<code>handler</code>：<code>handler</code>本身就是 ES6 所新设计的一个对象. 它的作用就是用来自定义代理对象的各种可代理操作。它本身一共有 13 中方法, 每种方法都可以代理一种操作，常用的几种方法如下:</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">// 在定义代理对象某个属性时的属性描述时触发该操作，比如在执行 Object.defineProperty(proxy, &quot;foo&quot;, &#123;&#125;) 时。</span>handler.defineProperty()<span class="hljs-comment">// 在判断代理对象是否拥有某个属性时触发该操作，比如在执行 &quot;foo&quot; in proxy 时。</span>handler.has()<span class="hljs-comment">// 在读取代理对象的某个属性时触发该操作，比如在执行 proxy.foo 时。</span>handler.get()<span class="hljs-comment">// 在给代理对象的某个属性赋值时触发该操作，比如在执行 proxy.foo = 1 时。</span>handler.set()<span class="hljs-comment">// 在删除代理对象的某个属性时触发该操作，比如在执行 delete proxy.foo 时。</span>handler.deleteProperty()<span class="hljs-comment">// 在获取代理对象的所有属性键时触发该操作，比如在执行 Object.getOwnPropertyNames(proxy) 时。</span>handler.ownKeys()<span class="hljs-comment">// 在调用一个目标对象为函数的代理对象时触发该操作，比如在执行 proxy() 时。</span>handler.apply()<span class="hljs-comment">// 在给一个目标对象为构造函数的代理对象构造实例时触发该操作，比如在执行new proxy() 时。</span>handler.construct()</code></pre><p>Proxy 对于代理模式 Proxy 的作用主要体现在三个方面:</p><ol><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ol><h2 id="Proxy-在-Vue3-0-中的应用原理"><a href="#Proxy-在-Vue3-0-中的应用原理" class="headerlink" title="Proxy 在 Vue3.0 中的应用原理"></a>Proxy 在 Vue3.0 中的应用原理</h2><p>上边已经说过了<code>Object.defineProperty</code>的劣势。相应的<code>Proxy</code>的优势就很明显了：</p><ul><li>Proxy 可以直接监听对象而非属性</li><li>Proxy 可以直接监听数组的变化</li><li>Proxy 有 13 中拦截方法，功能更强大。</li></ul><p>Proxy 的劣势： 兼容性问题, 而且无法用 polyfill 磨平, 因此 Vue 要到 3.0 版本才能用 Proxy 重写。</p><p>简单例子：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;input&#x27;</span>);<span class="hljs-keyword">const</span> p = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;p&#x27;</span>);<span class="hljs-keyword">const</span> obj = &#123;&#125;;<span class="hljs-keyword">const</span> newObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, &#123;  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, receiver</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`getting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);  &#125;,  set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value, receiver</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(target, key, value, receiver);    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;text&#x27;</span>) &#123;      input.value = value;      p.innerHTML = value;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);  &#125;,&#125;);input.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;  newObj.text = e.target.value;&#125;);</code></pre><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><blockquote><p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与处理器对象的方法相同。Reflect 不是一个函数对象，因此它是不可构造 (即不可<code>new Reflect</code>) 的。</p></blockquote><p><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p><p><strong>也就是说，Reflect.fn 表示 handler 中的 fn 的默认行为。</strong></p><p>这里我们看两段代码：</p><pre><code class="hljs js"><span class="hljs-comment">// 这里是get/set方法打印log之后，再执行默认行为</span><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;  get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, receiver</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`getting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);    <span class="hljs-comment">// 在浏览器console中，get方法会默认打印出值</span>    <span class="hljs-comment">// 如果没有Reflect.get执行默认行为，就无法正确打印出值，而会打印undefined</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);  &#125;,  set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, value, receiver</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`setting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);  &#125;&#125;);<span class="hljs-comment">// 这里是先执行默认的set确保默认行为执行，set成功之后在打印log，然后返回</span><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;  set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, name, value, receiver</span>) </span>&#123;    <span class="hljs-keyword">var</span> success = <span class="hljs-built_in">Reflect</span>.set(target,name, value, receiver);    <span class="hljs-keyword">if</span> (success) &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;property &#x27;</span> + name + <span class="hljs-string">&#x27; on &#x27;</span> + target + <span class="hljs-string">&#x27; set to &#x27;</span> + value);    &#125;    <span class="hljs-keyword">return</span> success;  &#125;&#125;);</code></pre><p>原文地址 <a href="https://blog.csdn.net/Creabine/article/details/87811207">https://blog.csdn.net/Creabine/article/details/87811207</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长回文子串</title>
    <link href="/2020/01/27/algorithm/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/01/27/algorithm/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-built_in">this</span>.isPalindrome = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> str === str.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);    &#125;;    <span class="hljs-keyword">let</span> ans = <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> len = s.length;    <span class="hljs-keyword">let</span> current = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (current &lt; len &amp;&amp; !max) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; current; i++) &#123;            <span class="hljs-keyword">let</span> tmpStr = s.substring(i, i + len - current + <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isPalindrome(tmpStr)) &#123;                ans = tmpStr;                max = current;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        current++;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;;</code></pre><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-keyword">let</span> n = s.length;    <span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;    <span class="hljs-keyword">let</span> dp = <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n), <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(n).fill(<span class="hljs-number">0</span>));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt; n; j++) &#123;            dp[i][j] = s[i] == s[j] &amp;&amp; (j - i &lt; <span class="hljs-number">2</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);            <span class="hljs-keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; res.length) &#123;                res = s.substring(i, j + <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res;&#125;;</code></pre><h3 id="中心扩展法"><a href="#中心扩展法" class="headerlink" title="中心扩展法"></a>中心扩展法</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-keyword">if</span>(!s || s.length &lt; <span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">return</span> s;    &#125;    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>,end = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> n = s.length;    <span class="hljs-comment">// 中心扩展法</span>    <span class="hljs-keyword">let</span> centerExpend = <span class="hljs-function">(<span class="hljs-params">left,right</span>) =&gt;</span> &#123;        <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])&#123;            left--;            right++;        &#125;        <span class="hljs-keyword">return</span> right - left - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;        <span class="hljs-keyword">let</span> len1 = centerExpend(i,i);        <span class="hljs-keyword">let</span> len2 = centerExpend(i,i+<span class="hljs-number">1</span>);        <span class="hljs-comment">// 两种组合取最大回文串的长度</span>        <span class="hljs-keyword">let</span> maxLen = <span class="hljs-built_in">Math</span>.max(len1,len2);        <span class="hljs-keyword">if</span>(maxLen &gt; end - start)&#123;            <span class="hljs-comment">// 更新最大回文串的首尾字符索引</span>            start = i - ((maxLen - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>);            end = i + (maxLen &gt;&gt; <span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> s.substring(start,end+<span class="hljs-number">1</span>);&#125;;</code></pre><h3 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!s || s.length &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> s;    &#125;    <span class="hljs-keyword">var</span> s_f = <span class="hljs-string">&#x27;#&#x27;</span> + s.split(<span class="hljs-string">&#x27;&#x27;</span>).join(<span class="hljs-string">&#x27;#&#x27;</span>) + <span class="hljs-string">&#x27;#&#x27;</span>;    <span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>, R = <span class="hljs-number">0</span>;    <span class="hljs-keyword">var</span> len = s.length;    <span class="hljs-keyword">var</span> t_len = s_f.length;    <span class="hljs-keyword">var</span> maxLen = <span class="hljs-number">0</span>;    <span class="hljs-keyword">var</span> maxIndex = <span class="hljs-number">0</span>;    <span class="hljs-keyword">var</span> originIndex = <span class="hljs-number">0</span>;    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(t_len);    p[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; t_len - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-keyword">var</span> j = <span class="hljs-number">2</span> * c - i;        <span class="hljs-keyword">if</span> (i &lt; R) &#123;            p[i] = <span class="hljs-built_in">Math</span>.min(p[j], R - i);        &#125; <span class="hljs-keyword">else</span> &#123;            p[i] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">var</span> left = i - p[i] - <span class="hljs-number">1</span>;        <span class="hljs-keyword">var</span> right = i + p[i] + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; t_len &amp;&amp; s_f[left] == s_f[right]) &#123;            left--;            right++;            p[i]++;        &#125;        <span class="hljs-keyword">if</span> (i + p[i] &gt; R) &#123;            c = i;            R = i + p[i];        &#125;        <span class="hljs-keyword">if</span> (p[i] &gt; maxLen) &#123;            maxLen = p[i];            maxIndex = i;            originIndex = <span class="hljs-built_in">Math</span>.floor((i - p[i]) / <span class="hljs-number">2</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> s.substring(originIndex, originIndex + maxLen);&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法与逻辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数柯里化及应用</title>
    <link href="/2019/09/25/write-code%20/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <url>/2019/09/25/write-code%20/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们在各种算法题以及技术文档中经常会看到柯里化这个词，那么，柯里化到底是什么？它在 js 中如何运用？对我们的编程有什么作用？都 9102 年了，如果你还不知道这些，那么你在面试过程中很可能会被面试官 diss🙄</p><a id="more"></a><hr><h3 id="什么是柯里化（Currying）"><a href="#什么是柯里化（Currying）" class="headerlink" title="什么是柯里化（Currying）"></a>什么是柯里化（Currying）</h3><p><em>维基百科</em>的<a href="https://links.jianshu.com/go?to=https://zh.wikipedia.org/wiki/%25E6%259F%25AF%25E9%2587%258C%25E5%258C%2596">解释</a>是：把接收多个参数的函数变换成接收一个单一参数（最初函数的第一个参数）的函数，并返回接受剩余的参数而且返回结果的新函数的技术。其由数学家 Haskell Brooks Curry 提出，并以 curry 命名。</p><p>简单的说，柯里化函数持续地返回一个新函数直到所有的参数用尽为止。这些参数全部保持 “活着” 的状态（通过闭包），然后当柯里化链中的最后一个函数被返回和执行时会全部被用来执行。</p><p>这和<a href="https://links.jianshu.com/go?to=https://react.docschina.org/docs/higher-order-components.html">高阶组件</a>（Higher-order functions）如出一辙。前者返回一个新函数，后者返回一个新组件。</p><h3 id="举个简单的栗子"><a href="#举个简单的栗子" class="headerlink" title="举个简单的栗子"></a>举个简单的栗子</h3><p>本例使用到的部分 ES6 知识：<a href="https://links.jianshu.com/go?to=http://es6.ruanyifeng.com/%23docs/let">const</a>，<a href="https://links.jianshu.com/go?to=http://es6.ruanyifeng.com/%23docs/function">arrow function</a>。不了解的同学可先行查看。<br>写一个计算三个参数相乘的函数：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span> (<span class="hljs-params">a, b, c</span>) </span>&#123;  <span class="hljs-keyword">return</span> a * b * c&#125;multiply(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</code></pre><p>这是我们第一反应写出来的 demo，也是看起来最简单的实现方法。再来创建一个柯里化版本的函数：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span> (<span class="hljs-params">a</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">b</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> a * b * c    &#125;  &#125;&#125;multiply(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)</code></pre><p>这里我们将 multiply(1，2，3) 调用变成了 multiply (1) (2) (3) 调用。<br>单独一个函数被转换成了一系列函数。为了得到数字 1、2、3 相乘的结果，这些数字被一个接一个地传递，每个数字预填了下一个函数内联调用。</p><p>我们把 multiply (1) (2) (3) 分割一下来帮助理解：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> mul1 = multiply(<span class="hljs-number">1</span>)<span class="hljs-keyword">const</span> mul2 = mul1(<span class="hljs-number">2</span>)<span class="hljs-keyword">const</span> result = mul2(<span class="hljs-number">3</span>)<span class="hljs-built_in">console</span>.log(result)</code></pre><p>当 mul2 使用 3 作为参数调用时，它一起使用了之前已拿到的参数 a=1 和 b=2 进行运算并返回结果 6。</p><p>作为一个嵌套函数，mul2 能够访问到外部的两个函数 multiply 和 mul1 的作用域。这就是为什么 mul2 能利用定义在已经‘离场’的函数中的参数来进行乘法操作的原因。即使这些函数早已返回并且从内存中垃圾回收了，但其变量仍然保持‘活着’(<a href="https://links.jianshu.com/go?to=https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449934543461c9d5dfeeb848f5b72bd012e1113d15000">闭包</a>)。你可以看到 3 个数字每次只有 1 个提供给函数，并且同一时间里一个新函数会被返回，直到所有的数字用尽为止。</p><p><strong>柯里化背后的逻辑就是获取一个函数并派生出一个返回特殊函数的函数</strong>，它实际上是一种思想，或者说是一种程序设计模式。</p><h3 id="柯里化的应用"><a href="#柯里化的应用" class="headerlink" title="柯里化的应用"></a>柯里化的应用</h3><h4 id="1-编写可以轻松复用和配置的小代码块，就像我们使用-npm-一样："><a href="#1-编写可以轻松复用和配置的小代码块，就像我们使用-npm-一样：" class="headerlink" title="1. 编写可以轻松复用和配置的小代码块，就像我们使用 npm 一样："></a>1. 编写可以轻松复用和配置的小代码块，就像我们使用 npm 一样：</h4><p>举个例子，你有一家商店，然后你想给你的优惠顾客 10% 的折扣：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">discount</span> (<span class="hljs-params">price, discount</span>) </span>&#123;  <span class="hljs-keyword">return</span> price * discount&#125;<span class="hljs-keyword">const</span> price = discount(<span class="hljs-number">500</span>, <span class="hljs-number">0.1</span>) <span class="hljs-keyword">const</span> price = discount(<span class="hljs-number">1500</span>, <span class="hljs-number">0.1</span>) <span class="hljs-keyword">const</span> price = discount(<span class="hljs-number">2000</span>, <span class="hljs-number">0.1</span>) <span class="hljs-keyword">const</span> price = discount(<span class="hljs-number">50</span>, <span class="hljs-number">0.1</span>) <span class="hljs-keyword">const</span> price = discount(<span class="hljs-number">300</span>, <span class="hljs-number">0.1</span>) <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">discount</span> (<span class="hljs-params">discount</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">price</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> price * discount  &#125;&#125;<span class="hljs-keyword">const</span> tenPercentDiscount = discount(<span class="hljs-number">0.1</span>)tenPercentDiscount(<span class="hljs-number">500</span>) <span class="hljs-keyword">const</span> twentyPercentDiscount = discount(<span class="hljs-number">0.2</span>)twentyPercentDiscount(<span class="hljs-number">500</span>) twentyPercentDiscount(<span class="hljs-number">3000</span>) twentyPercentDiscount(<span class="hljs-number">80000</span>)</code></pre><p>这个例子说明，使用柯里化思想能让我们在遇到只能确定一个参数而无法确定另一个参数时，代码设计编的变得更方便与高效，达到提升性能的目的。</p><h4 id="2-避免频繁调用具有相同参数的函数："><a href="#2-避免频繁调用具有相同参数的函数：" class="headerlink" title="2. 避免频繁调用具有相同参数的函数："></a>2. 避免频繁调用具有相同参数的函数：</h4><p>比如我们有个用来计算体积的函数:</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">volume</span> (<span class="hljs-params">l, w, h</span>) </span>&#123;  <span class="hljs-keyword">return</span> l * w * h&#125;volume(<span class="hljs-number">200</span>, <span class="hljs-number">30</span>, <span class="hljs-number">100</span>) volume(<span class="hljs-number">32</span>, <span class="hljs-number">45</span>, <span class="hljs-number">100</span>) volume(<span class="hljs-number">2322</span>, <span class="hljs-number">232</span>, <span class="hljs-number">100</span>) <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">volume</span> (<span class="hljs-params">h</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">w</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">l</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> l * w * h    &#125;  &#125;&#125;<span class="hljs-keyword">const</span> hCylinderHeight = volume(<span class="hljs-number">100</span>)hCylinderHeight(<span class="hljs-number">200</span>)(<span class="hljs-number">30</span>) hCylinderHeight(<span class="hljs-number">2322</span>)(<span class="hljs-number">232</span>)</code></pre><h3 id="通用的柯里函数"><a href="#通用的柯里函数" class="headerlink" title="通用的柯里函数"></a>通用的柯里函数</h3><p>让我们建立一个函数来接受任何函数并且返回柯里化版本的函数：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span> (<span class="hljs-params">fn, ...args</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">..._args</span>) =&gt;</span> &#123;    <span class="hljs-keyword">return</span> fn(...args, ..._args)  &#125;&#125;</code></pre><p>我们在这里做了什么？我们的 curry 函数接受一个我们想要柯里化的函数（fn）和一个变量（…args）。这里的 rest 操作符用来将参数聚集成一个…args。接下来我们返回一个函数，该函数将其余参数收集为…<em>args。此函数通过 spread 运算符将… args 和…</em> args 作为参数解构传入来调用原始函数 fn，然后将值返回给用户。</p><p>让我们使用我们的 curry 函数用之前的例子来创建一个特殊的函数（一个专门用来计算 100m 长度的物品体积）：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">volume</span> (<span class="hljs-params">l, h, w</span>) </span>&#123;  <span class="hljs-keyword">return</span> l * h * w&#125;<span class="hljs-keyword">const</span> hCy = curry(volume, <span class="hljs-number">100</span>)hCy(<span class="hljs-number">200</span>, <span class="hljs-number">900</span>) hCy(<span class="hljs-number">70</span>, <span class="hljs-number">60</span>)</code></pre><p>将类似回调函数的参数传入柯里化函数，能使复杂的问题变得简单！</p><h3 id="使用递归实现-curry-函数"><a href="#使用递归实现-curry-函数" class="headerlink" title="使用递归实现 curry 函数"></a>使用递归实现 curry 函数</h3><p>JS 柯里化作为函数式编程的重要一环，频繁在算法题中出现。以上的通用柯里化函数还不够完善，我们希望只给 curry 函数传递一个 fn 就能达到目的，现在我们使用递归来实现：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;  <span class="hljs-keyword">const</span> c = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> (args.length === fn.length) ?          fn(...args) : <span class="hljs-function">(<span class="hljs-params">..._args</span>) =&gt;</span> c(...args, ..._args)  <span class="hljs-keyword">return</span> c&#125;</code></pre><p>该方法几乎为最简洁、代码行数最少的实现方法了。<br>首先我们能确定，实现柯里化的核心就是要确定传入参数的个数，并通通取到。<br>其次，我们得知道，<code>fn.length</code>为 fn 函数接受的参数个数，那么该实现方法就能解读为：<br><strong>不断递归获取传入参数，直到取到的参数个数等于 fn 的参数个数为止，最终将获取到的所有参数传给 fn 并返回执行结果</strong>。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>柯里化作为一种重要的程序思想，已经广为应用，它使我们应对复杂问题时能提升效率，增强可读性。希望读者都能体会这种思想并运用于实践，相信在提升技术的路上能越走越远，成为一名优秀的工程师！</p><p><a href="https://www.jianshu.com/p/7fa99a4bee8b">原文地址</a></p><h3 id="由浅入深的柯里化"><a href="#由浅入深的柯里化" class="headerlink" title="由浅入深的柯里化"></a>由浅入深的柯里化</h3><p>在前端面试中有一个关于柯里化的面试题，流传甚广。</p><blockquote><p>实现一个add方法，使计算结果能够满足如下预期：<br>add(1)(2)(3) = 6<br>add(1, 2)(3, 4) = 10<br>add(1)(2)(3)(4)(5) = 15</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-comment">// 在内部声明一个函数，利用闭包的特性保存args并收集所有的参数值</span>    <span class="hljs-keyword">let</span> allArgs = args;    <span class="hljs-keyword">const</span> adder = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">const</span> setter = <span class="hljs-function">(<span class="hljs-params">...setterArgs</span>) =&gt;</span> &#123;            allArgs = allArgs.concat([...setterArgs]);            <span class="hljs-keyword">return</span> setter;        &#125;;        <span class="hljs-comment">// 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span>        setter.valueOf = <span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-keyword">return</span> allArgs.reduce(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;                <span class="hljs-keyword">return</span> a + b;            &#125;);        &#125;;        <span class="hljs-keyword">return</span> setter;    &#125;;    <span class="hljs-keyword">return</span> adder();&#125;<span class="hljs-comment">// 输出结果，可自由组合的参数</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)));  <span class="hljs-comment">// 6</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)));  <span class="hljs-comment">// 10</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)));  <span class="hljs-comment">// 15</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>手撕代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现Symbol</title>
    <link href="/2019/07/09/write-code%20/%E5%AE%9E%E7%8E%B0Symbol/"/>
    <url>/2019/07/09/write-code%20/%E5%AE%9E%E7%8E%B0Symbol/</url>
    
    <content type="html"><![CDATA[<h2 id="ES6-Symbol特点"><a href="#ES6-Symbol特点" class="headerlink" title="ES6 Symbol特点"></a>ES6 Symbol特点</h2><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p><ul><li>Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。</li><li>instanceof 的结果为 false</li><li>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述</li><li>如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。</li><li>Symbol 函数的参数只是表示对当前 Symbol 值的描述，相同参数的 Symbol 函数的返回值是不相等的。</li><li>Symbol 值不能与其他类型的值进行运算，会报错。</li><li>Symbol 值可以显式转为字符串。</li><li>Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。</li><li>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。</li><li>如果我们希望使用同一个 Symbol 值，可以使用 Symbol.for。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</li><li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li></ul><pre><code class="hljs js"><span class="hljs-built_in">window</span>.mySymbolMap = &#123;&#125;;<span class="hljs-keyword">const</span> generateName = (<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-keyword">let</span> postfix = <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">descString</span>) =&gt;</span> &#123;        postfix++;        <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;descString&#125;</span>_<span class="hljs-subst">$&#123;postfix&#125;</span>`</span>;    &#125;;&#125;)();<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MySymbol</span>(<span class="hljs-params">description</span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> MySymbol) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(        <span class="hljs-string">&#x27;Symbol is not a constructor&#x27;</span>);    <span class="hljs-keyword">const</span> descString = description === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-built_in">String</span>(        description);    <span class="hljs-keyword">const</span> symbol = <span class="hljs-built_in">Object</span>.create(&#123;        toString() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.__Name__;        &#125;,        valueOf() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;        &#125;    &#125;);    <span class="hljs-built_in">Object</span>.defineProperties(symbol, &#123;        <span class="hljs-string">&#x27;__Description__&#x27;</span>: &#123;            value: descString,            writable: <span class="hljs-literal">false</span>,            enumerable: <span class="hljs-literal">false</span>,            configurable: <span class="hljs-literal">false</span>        &#125;,        <span class="hljs-string">&#x27;__Name__&#x27;</span>: &#123;            value: generateName(descString),            writable: <span class="hljs-literal">false</span>,            enumerable: <span class="hljs-literal">false</span>,            configurable: <span class="hljs-literal">false</span>        &#125;    &#125;);    <span class="hljs-keyword">return</span> symbol;&#125;<span class="hljs-built_in">Object</span>.defineProperties(MySymbol, &#123;    <span class="hljs-string">&#x27;for&#x27;</span>: &#123;        value(description) &#123;            <span class="hljs-keyword">const</span> descString = description === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-built_in">String</span>(                description);            <span class="hljs-keyword">return</span> mySymbolMap[descString]                ? mySymbolMap[descString]                : mySymbolMap[descString] = MySymbol(descString);        &#125;,        writable: <span class="hljs-literal">true</span>,        enumerable: <span class="hljs-literal">false</span>,        configurable: <span class="hljs-literal">true</span>    &#125;,    <span class="hljs-string">&#x27;keyFor&#x27;</span>: &#123;        value(symbol) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> mySymbolMap) &#123;                <span class="hljs-keyword">if</span> (mySymbolMap[key] === symbol) <span class="hljs-keyword">return</span> key;            &#125;        &#125;,        writable: <span class="hljs-literal">true</span>,        enumerable: <span class="hljs-literal">false</span>,        configurable: <span class="hljs-literal">true</span>    &#125;&#125;);<span class="hljs-keyword">const</span> test = MySymbol(<span class="hljs-number">1</span>);<span class="hljs-keyword">const</span> test1 = MySymbol(<span class="hljs-number">1</span>);<span class="hljs-keyword">const</span> a = &#123;    [test]: <span class="hljs-number">1</span>,    [test1]: <span class="hljs-number">12</span>&#125;;a[MySymbol(<span class="hljs-string">&#x27;test&#x27;</span>)] = <span class="hljs-number">123</span>;a[MySymbol(<span class="hljs-string">&#x27;test&#x27;</span>)] = <span class="hljs-number">1234</span>;<span class="hljs-keyword">const</span> foo = MySymbol(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-keyword">const</span> s1 = MySymbol.for(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-keyword">const</span> s2 = MySymbol.for(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(test));<span class="hljs-built_in">console</span>.log(test === test1);<span class="hljs-built_in">console</span>.log(a);<span class="hljs-built_in">console</span>.log(s1 === s1);<span class="hljs-built_in">console</span>.log(MySymbol.keyFor(s1));</code></pre>]]></content>
    
    
    <categories>
      
      <category>手撕代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue兄弟组件间传数据的方法-事件</title>
    <link href="/2019/06/05/vue/vue%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6/"/>
    <url>/2019/06/05/vue/vue%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="vm-on-event-callback-vue-API"><a href="#vm-on-event-callback-vue-API" class="headerlink" title="vm.$on(event, callback)vue API"></a>vm.$on(event, callback)<a href="https://cn.vuejs.org/v2/api/#vm-on">vue API</a></h2><a id="more"></a><p><strong>用法：</strong> 监听当前实例上的自定义事件。事件可以由 <code>vm.$emit</code> 触发。回调函数会接收所有传入事件触发函数的额外参数。</p><pre><code class="hljs js">vm.$on(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(msg)&#125;)vm.$emit(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;hi&#x27;</span>)<span class="hljs-comment">// =&gt; &quot;hi&quot;</span></code></pre><h2 id="vm-once-event-callback-vue-API"><a href="#vm-once-event-callback-vue-API" class="headerlink" title="vm.$once(event, callback) vue API"></a>vm.$once(event, callback) <a href="https://cn.vuejs.org/v2/api/#vm-once">vue API</a></h2><p><strong>用法：</strong> 监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。</p><h2 id="vm-off-event-callback-vue-API"><a href="#vm-off-event-callback-vue-API" class="headerlink" title="vm.$off([event, callback] ) vue API"></a>vm.$off([event, callback] ) <a href="https://cn.vuejs.org/v2/api/#vm-off">vue API</a></h2><p><strong>用法：</strong></p><ul><li><p>移除自定义事件监听器。</p><ol><li><p>如果没有提供参数，则移除所有的事件监听器；</p></li><li><p>如果只提供了事件，则移除该事件所有的监听器；</p></li><li><p>如果同时提供了事件与回调，则只移除这个回调的监听器。</p></li></ol></li></ul><h2 id="vm-emit-eventName-…args-vue-API"><a href="#vm-emit-eventName-…args-vue-API" class="headerlink" title="vm.$emit(eventName, […args] ) vue API"></a>vm.$emit(eventName, […args] ) <a href="https://cn.vuejs.org/v2/api/#vm-emit">vue API</a></h2><p><strong>用法：</strong> 触发当前实例上的事件。附加参数都会传给监听器回调。<br>示例：只配合一个事件名使用 $emit：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">welcome-button</span> <span class="hljs-attr">v-on:welcome</span>=<span class="hljs-string">&quot;sayHi&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">welcome-button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>Vue.component(&#x27;welcome-button&#x27;, &#123;  template: `    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;$emit(&#x27;welcome&#x27;)&quot;</span>&gt;</span>      Click me to be welcomed    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  `&#125;)new Vue(&#123;  el: &#x27;#emit-example-simple&#x27;,  methods: &#123;    sayHi: function () &#123;      alert(&#x27;Hi!&#x27;)    &#125;  &#125;&#125;)</code></pre><p>配合额外的参数使用 <code>$emit</code>：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 添加事件侦听器  --&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">magic-eight-ball</span> <span class="hljs-attr">v-on:give-advice</span>=<span class="hljs-string">&quot;showAdvice&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">magic-eight-ball</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>Vue.component(&#x27;magic-eight-ball&#x27;, &#123;  data: function () &#123;    return &#123;      possibleAdvice: [&#x27;Yes&#x27;, &#x27;No&#x27;, &#x27;Maybe&#x27;]    &#125;  &#125;,  methods: &#123;    giveAdvice: function () &#123;    //根据数组长度 随机取数      var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)      //触发示例事件  从数组中随机取一元素传参      this.$emit(&#x27;give-advice&#x27;, this.possibleAdvice[randomAdviceIndex])    &#125;  &#125;,  template: `    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;giveAdvice&quot;</span>&gt;</span>      Click me for advice    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  `&#125;)new Vue(&#123;  el: &#x27;#emit-example-argument&#x27;,  methods: &#123;    showAdvice: function (advice) &#123;      alert(advice)    &#125;  &#125;&#125;)</code></pre><h2 id="兄弟组件传数据"><a href="#兄弟组件传数据" class="headerlink" title="兄弟组件传数据"></a>兄弟组件传数据</h2><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>兄弟组件数据交互<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;handle&#x27;</span>&gt;</span>销毁事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">aaa</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aaa</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bbb</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bbb</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"><span class="hljs-comment">// 提供事件中心</span></span><span class="javascript"><span class="hljs-keyword">var</span> hub=<span class="hljs-keyword">new</span> Vue();</span><span class="javascript"><span class="hljs-comment">// 组件  aaa</span></span><span class="javascript">Vue.component(<span class="hljs-string">&#x27;aaa&#x27;</span>,&#123;</span><span class="javascript">data:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript"><span class="hljs-keyword">return</span>&#123;</span><span class="javascript">content:<span class="hljs-string">&#x27;这里是a&#x27;</span>,</span><span class="javascript">txt:<span class="hljs-string">&#x27;我是a被给到兄弟的数据~~~&#x27;</span>,</span><span class="javascript">test:<span class="hljs-string">&#x27;这里的数据会变化的！！！&#x27;</span></span>&#125;&#125;,<span class="handlebars"><span class="xml">template:&quot;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">content</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">test</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;changes&#x27;</span>&gt;</span>数据给b<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&quot;,</span></span>methods:&#123;<span class="javascript">changes:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">hub.$emit(<span class="hljs-string">&#x27;aaaData&#x27;</span>,<span class="hljs-built_in">this</span>.txt);</span>&#125;&#125;,<span class="javascript">mounted:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript">hub.$on(<span class="hljs-string">&#x27;bbbData&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">val</span>)=&gt;</span>&#123;</span><span class="javascript"><span class="hljs-built_in">this</span>.test=val;</span>&#125;);&#125;&#125;);<span class="javascript"><span class="hljs-comment">// 组件  bbb</span></span><span class="javascript">Vue.component(<span class="hljs-string">&#x27;bbb&#x27;</span>,&#123;</span><span class="javascript">data:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><span class="javascript"><span class="hljs-keyword">return</span>&#123;</span><span class="javascript">content:<span class="hljs-string">&#x27;这里是b&#x27;</span>,</span><span class="javascript">txt:<span class="hljs-string">&#x27;我是b给到a兄弟下的数据&#x27;</span>,</span><span class="javascript">test:<span class="hljs-string">&#x27;这里的数据会变化的！！！&#x27;</span></span>&#125;&#125;,<span class="handlebars"><span class="xml">template:&quot;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">content</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">test</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&#x27;changes&#x27;</span>&gt;</span>数据给a<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>\</span></span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&quot;,</span></span>methods:&#123;changes()&#123;<span class="javascript">hub.$emit(<span class="hljs-string">&#x27;bbbData&#x27;</span>,<span class="hljs-built_in">this</span>.txt);</span>&#125;&#125;,mounted() &#123;<span class="javascript">hub.$on(<span class="hljs-string">&#x27;aaaData&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">val</span>)=&gt;</span>&#123;</span><span class="javascript"><span class="hljs-built_in">this</span>.test=val;</span>&#125;)&#125;&#125;)<span class="javascript"><span class="hljs-comment">// 实例化 Vue</span></span><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">el: <span class="hljs-string">&quot;#app&quot;</span>,</span>data: &#123;&#125;,methods: &#123;<span class="javascript"><span class="hljs-comment">//移除自定义事件监听器。</span></span>handle()&#123;<span class="javascript">hub.$off(<span class="hljs-string">&#x27;aaaData&#x27;</span>);</span><span class="javascript">hub.$off(<span class="hljs-string">&#x27;bbbData&#x27;</span>);</span>&#125;&#125;&#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>框架、库学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>千位分隔符</title>
    <link href="/2019/03/19/algorithm/%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E7%AC%A6/"/>
    <url>/2019/03/19/algorithm/%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="千位分隔符"><a href="#千位分隔符" class="headerlink" title="千位分隔符"></a>千位分隔符</h3><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thousandBitSeparator</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">return</span> num.toString().replace(<span class="hljs-regexp">/\d+/</span>, <span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> &#123; <span class="hljs-comment">// 先提取整数部分</span>        <span class="hljs-keyword">return</span> n.replace(<span class="hljs-regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="hljs-function">(<span class="hljs-params">$<span class="hljs-number">1</span></span>) =&gt;</span> &#123;            <span class="hljs-keyword">return</span> $<span class="hljs-number">1</span> + <span class="hljs-string">&#x27;,&#x27;</span>;        &#125;);    &#125;);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法与逻辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现Promise、Promise.all</title>
    <link href="/2019/01/16/write-code%20/%E5%AE%9E%E7%8E%B0Promise%E3%80%81Promise.all/"/>
    <url>/2019/01/16/write-code%20/%E5%AE%9E%E7%8E%B0Promise%E3%80%81Promise.all/</url>
    
    <content type="html"><![CDATA[<h3 id="实现Promise"><a href="#实现Promise" class="headerlink" title="实现Promise"></a>实现Promise</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;pending&#x27;</span>;<span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;fulfilled&#x27;</span>;<span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;rejected&#x27;</span>;<span class="hljs-keyword">const</span> NewPromise = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">executor</span>) </span>&#123;  <span class="hljs-keyword">const</span> _this = <span class="hljs-built_in">this</span>;  _this.status = PENDING;  _this.data = <span class="hljs-literal">undefined</span>;  _this.onResolvedCallback = [];  _this.onRejectedCallback = [];  <span class="hljs-comment">// 成功</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;      <span class="hljs-keyword">return</span> value.then(resolve, reject)    &#125;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 异步执行所有的回调函数</span>      <span class="hljs-keyword">if</span> (_this.status === PENDING) &#123;        _this.status = FULFILLED;        _this.data = value;        _this.onResolvedCallback.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> callback(value));      &#125;    &#125;)  &#125;  <span class="hljs-comment">// 失败</span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 异步执行所有的回调函数</span>      <span class="hljs-keyword">if</span> (_this.status === PENDING) &#123;        _this.status = REJECTED;        _this.data = reason;        _this.onRejectedCallback.forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> callback(reason));      &#125;    &#125;)  &#125;  <span class="hljs-keyword">try</span> &#123;    executor(resolve, reject);  &#125; <span class="hljs-keyword">catch</span> (error) &#123;    reject(error);  &#125;&#125;  <span class="hljs-comment">// then</span>NewPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) </span>&#123;  <span class="hljs-keyword">const</span> _this = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> onResolved !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;   onResolved = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-keyword">return</span> value &#125;  &#125;  <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;    onRejected = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>&#123; <span class="hljs-keyword">throw</span> reason &#125;  &#125;  <span class="hljs-comment">// 公共判断</span>  <span class="hljs-keyword">const</span> common = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, resolve, reject</span>) </span>&#123;    <span class="hljs-comment">// 考虑到有可能throw，我们将其包在try/catch块里</span>    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">let</span> value = _this.status === FULFILLED        ? onResolved(data)        : onRejected(data)      <span class="hljs-keyword">if</span>( value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;        value.then(resolve, reject)      &#125;      resolve(value)    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      reject(error)    &#125;  &#125;  <span class="hljs-comment">// 公共判断</span>  <span class="hljs-keyword">const</span> pendingCommon = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data, flag, resolve, reject</span>) </span>&#123;    <span class="hljs-comment">// 考虑到有可能throw，我们将其包在try/catch块里</span>    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">let</span> value = flag === FULFILLED        ? onResolved(data)        : onRejected(data)      <span class="hljs-keyword">if</span>( value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;        value.then(resolve, reject)      &#125;      resolve(value)    &#125; <span class="hljs-keyword">catch</span> (error) &#123;      reject(error)    &#125;  &#125;  <span class="hljs-keyword">if</span> (_this.status === PENDING) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;      _this.onResolvedCallback.push(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;        pendingCommon(value, FULFILLED, resolve, reject);      &#125;)      _this.onRejectedCallback.push(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;        pendingCommon(reason, REJECTED, resolve, reject);      &#125;)    &#125;)  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// resolve / reject</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        common(_this.data, resolve, reject)      &#125;)    &#125;)  &#125;&#125;NewPromise.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) <span class="hljs-keyword">return</span> value;    <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 判断如果是promise</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断是否有then方法</span>            <span class="hljs-keyword">let</span> then = value.then;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise(then.call(value)); <span class="hljs-comment">// 执行value方法</span>            &#125;        &#125; <span class="hljs-keyword">catch</span> (e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;                reject(e);            &#125;);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;      resolve(value);  &#125;);&#125;NewPromise.reject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) <span class="hljs-keyword">return</span> value;    <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">// 判断如果是promise</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 判断是否有then方法</span>            <span class="hljs-keyword">let</span> then = value.then;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise(then.call(value)); <span class="hljs-comment">// 执行value方法</span>            &#125;        &#125; <span class="hljs-keyword">catch</span> (e) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;                reject(e);            &#125;);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise( <span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;      reject(value);  &#125;);&#125;<span class="hljs-comment">// catch方法</span>NewPromise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onRejected</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onRejected)&#125;<span class="hljs-comment">// finally</span>NewPromise.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fun</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> NewPromise.resolve(fun()).then(<span class="hljs-function">() =&gt;</span> value);    &#125;, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;      <span class="hljs-keyword">return</span> NewPromise.resolve(fun()).then(<span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">throw</span> err;    &#125;);  &#125;);&#125;;<span class="hljs-comment">// defered</span>NewPromise.deferred = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> dfd = &#123;&#125;  dfd.promise = <span class="hljs-keyword">new</span> NewPromise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;    dfd.resolve = resolve    dfd.reject = reject  &#125;)  <span class="hljs-keyword">return</span> dfd&#125;<span class="hljs-comment">// all</span>NewPromise.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> result = []    promises = <span class="hljs-built_in">Array</span>.isArray(promises) ? promises : []    <span class="hljs-keyword">const</span> len = promises.length;    <span class="hljs-keyword">if</span>(len === <span class="hljs-number">0</span>) resolve([]);    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;      <span class="hljs-keyword">if</span>(promises[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;          promises[i].then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;            count ++            result[i] = value            <span class="hljs-keyword">if</span> (count === len) resolve(result)          &#125;, reject)      &#125; <span class="hljs-keyword">else</span> &#123;        result[i] = promises[i]      &#125;    &#125;  &#125;) &#125;<span class="hljs-comment">// race</span>NewPromise.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    promises = <span class="hljs-built_in">Array</span>.isArray(promises) ? promises : []    promises.forEach(<span class="hljs-function"><span class="hljs-params">promise</span> =&gt;</span> &#123;      promise.then(resolve, reject)    &#125;)  &#125;)&#125;<span class="hljs-comment">// allSettled</span>NewPromise.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NewPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    promises = <span class="hljs-built_in">Array</span>.isArray(promises) ? promises : []    <span class="hljs-keyword">let</span> len = promises.length;    <span class="hljs-keyword">const</span> argslen = len;    <span class="hljs-keyword">if</span> (len === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> resolve([]);    <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(promises);    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">index, value</span>) </span>&#123;      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;        <span class="hljs-keyword">const</span> then = value.then;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>)&#123;          then.call(value, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;            args[index] = &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, <span class="hljs-attr">value</span>: val&#125;;            <span class="hljs-keyword">if</span>(--len === <span class="hljs-number">0</span>) &#123;              resolve(args);            &#125;          &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;            args[index] = &#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, <span class="hljs-attr">reason</span>: e &#125;;            <span class="hljs-keyword">if</span>(--len === <span class="hljs-number">0</span>) &#123;              reject(args);            &#125;          &#125;)        &#125;      &#125;    &#125;     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; argslen; i++)&#123;      resolvePromise(i, args[i]);    &#125;  &#125;)&#125;<span class="hljs-comment">// 测试</span><span class="hljs-comment">// const promise = new NewPromise(function(resolve, reject) &#123;</span><span class="hljs-comment">//   console.log(&#x27;ss&#x27;, 11)</span><span class="hljs-comment">//   // resolve(123)</span><span class="hljs-comment">//   reject(&#x27;errr&#x27;)</span><span class="hljs-comment">//   // throw &#x27;ree&#x27;</span><span class="hljs-comment">// &#125;)</span><span class="hljs-comment">// promise.catch(val =&gt; &#123;</span><span class="hljs-comment">//   console.log(&#x27;val&#x27;, val)</span><span class="hljs-comment">// &#125;)</span><span class="hljs-comment">// const promise1 = new NewPromise(function(resolve, reject) &#123;</span><span class="hljs-comment">//   console.log(&#x27;ss&#x27;, 11)</span><span class="hljs-comment">//   resolve(123)</span><span class="hljs-comment">//   // reject(&#x27;errr&#x27;)</span><span class="hljs-comment">// &#125;)</span><span class="hljs-comment">// const rejected = NewPromise.reject(-1);</span><span class="hljs-comment">// rejected.catch(val =&gt; &#123;</span><span class="hljs-comment">//     console.log(&#x27;rejected&#x27;, val)</span><span class="hljs-comment">//   &#125;)</span><span class="hljs-comment">// console.log(&#x27;resolved&#x27;, resolved)</span><span class="hljs-keyword">const</span> resolved = NewPromise.resolve(<span class="hljs-number">1</span>);<span class="hljs-keyword">const</span> rejected = NewPromise.reject(<span class="hljs-number">-1</span>);<span class="hljs-keyword">const</span> resolved1 = NewPromise.resolve(<span class="hljs-number">17</span>);<span class="hljs-keyword">const</span> p = NewPromise.all([resolved, resolved1, rejected]);p.then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;result&#x27;</span>, result)&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;err&#x27;</span>, err)&#125;)</code></pre><h3 id="实现Promise-all"><a href="#实现Promise-all" class="headerlink" title="实现Promise.all"></a>实现Promise.all</h3><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.myall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> resolve([])        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">let</span> res = [],                count = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;                <span class="hljs-comment">// 同时也能处理arr数组中非Promise对象</span>                <span class="hljs-keyword">if</span> (!(arr[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;                    res[i] = arr[i]                    <span class="hljs-keyword">if</span> (++count === arr.length)                        resolve(res)                &#125; <span class="hljs-keyword">else</span> &#123;                    arr[i].then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;                        res[i] = data                        <span class="hljs-keyword">if</span> (++count === arr.length)                            resolve(res)                    &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                        reject(err)                    &#125;)                &#125;            &#125;        &#125;    &#125;)&#125;</code></pre><h3 id="实现Promise-race"><a href="#实现Promise-race" class="headerlink" title="实现Promise.race"></a>实现Promise.race</h3><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.myrace = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-comment">// 同时也能处理arr数组中非Promise对象</span>            <span class="hljs-keyword">if</span> (!(arr[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)) &#123;                <span class="hljs-built_in">Promise</span>.resolve(arr[i]).then(resolve, reject)            &#125; <span class="hljs-keyword">else</span> &#123;                arr[i].then(resolve, reject)            &#125;        &#125;    &#125;)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>手撕代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的dom更新机制 &amp; Vue的nextTick</title>
    <link href="/2019/01/09/vue/Vue%E7%9A%84dom%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%20&amp;%20Vue%E7%9A%84nextTick/"/>
    <url>/2019/01/09/vue/Vue%E7%9A%84dom%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%20&amp;%20Vue%E7%9A%84nextTick/</url>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><blockquote><p>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</p></blockquote><blockquote><p>简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</p></blockquote><blockquote><p>同步里执行的方法，每个方法里做的事情组成一个事件循环；接下来再次调用的是另一个事件循环。</p></blockquote><blockquote><p>nextTick：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，会获取更新后的 DOM。</p></blockquote><h3 id="nextTick用法："><a href="#nextTick用法：" class="headerlink" title="$nextTick用法："></a>$nextTick用法：</h3><pre><code class="hljs js"><span class="hljs-comment">//改变数据</span>vm.message = <span class="hljs-string">&#x27;changed&#x27;</span>;<span class="hljs-comment">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span><span class="hljs-built_in">console</span>.log(vm.$el.textContent); <span class="hljs-comment">// 并不会得到&#x27;changed&#x27;</span><span class="hljs-comment">//这样可以，nextTick里面的代码会在DOM更新后执行</span>Vue.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(vm.$el.textContent); <span class="hljs-comment">//可以得到&#x27;changed&#x27;</span>&#125;);</code></pre><h3 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h3><p><img src="/images/pages/1234412-20191114161514728-1287582393.png" alt="image"></p><p>上图中第一块：</p><p>1 首先修改数据，这是同步任务。同一事件循环的所有的同步任务都在主线程上执行，形成一个执行栈，此时还未涉及 DOM 。</p><p>2 Vue 开启一个异步队列，并缓冲在此事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。</p><p>上图中第二块：</p><p>同步任务执行完毕，开始执行异步 watcher 队列的任务，更新 DOM 。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel 方法，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。</p><p>上图中第三块：</p><p>下次 DOM 更新循环结束之后，此时通过 Vue.nextTick 获取到改变后的 DOM 。通过 setTimeout(fn, 0) 也可以同样获取到。</p><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><blockquote><p>需要注意的是，在 created 和 mounted 阶段，如果需要操作渲染后的试图，也要使用 nextTick 方法。<br>官方文档说明：mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick：</p></blockquote><pre><code class="hljs actionscript">mounted() &#123;    <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Code that will run only after the</span>        <span class="hljs-comment">// entire view has been rendered</span>    &#125;);&#125;</code></pre><pre><code class="hljs dart">showsou() &#123;    <span class="hljs-comment">// 显示输入框</span>    <span class="hljs-keyword">this</span>.showInput = <span class="hljs-keyword">true</span>;    <span class="hljs-comment">// 此时事件循环还没有结束，dom没有更新，获取不到input，不能使他产生焦点</span>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;keywords&#x27;</span>).focus();&#125;</code></pre><pre><code class="hljs javascript">showsou() &#123;    <span class="hljs-built_in">this</span>.showInput = <span class="hljs-literal">true</span>;    <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// DOM 更新了</span>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;keywords&#x27;</span>).focus();    &#125;);&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myWidth&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;showMe&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getMyWidth&quot;</span>&gt;</span>获取p元素宽度<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>getMyWidth() &#123;    this.showMe = true;    // 以下代码报错 TypeError: this.$refs.myWidth is undefined    // this.message = this.$refs.myWidth.offsetWidth;    this.$nextTick(()=&gt;&#123;        // dom元素更新后执行，此时能拿到p元素的属性        this.message = this.$refs.myWidth.offsetWidth;    &#125;)&#125;</code></pre><p><img src="/images/pages/1234412-20200418162600879-352593538.png" alt="image"></p>]]></content>
    
    
    <categories>
      
      <category>框架、库学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表的倒数第K个结点</title>
    <link href="/2018/11/27/algorithm/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2018/11/27/algorithm/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>删除链表的倒数第 K 个结点 [要求 Tc: O(L) Sc:O(1)]</p><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LeetCode 第 19 题</a></p><h4 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h4><pre><code class="hljs js"><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) </span>&#123;    <span class="hljs-keyword">const</span> findNode = <span class="hljs-function">(<span class="hljs-params">node, n, tempNode, level = <span class="hljs-number">0</span></span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (node.next) &#123;            <span class="hljs-keyword">if</span> (level &lt; n) &#123;                <span class="hljs-keyword">return</span> findNode(node.next, n, tempNode, level + <span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> findNode(node.next, n, tempNode.next, level);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (level === n) &#123;                <span class="hljs-keyword">return</span> tempNode;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;            &#125;        &#125;    &#125;;    <span class="hljs-keyword">const</span> deletedNode = findNode(head, n, head);    <span class="hljs-keyword">if</span> (deletedNode &amp;&amp; deletedNode.next) &#123;        deletedNode.next = deletedNode.next.next;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">if</span> (head.next) &#123;            head = head.next;        &#125; <span class="hljs-keyword">else</span> &#123;            head = <span class="hljs-literal">null</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> head;&#125;;</code></pre><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><pre><code class="hljs js"><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) </span>&#123;    <span class="hljs-keyword">let</span> dummyNode = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);    dummyNode.next = head;    <span class="hljs-keyword">let</span> fast = dummyNode, slow = dummyNode;    <span class="hljs-comment">// 快先走 n+1 步</span>    <span class="hljs-keyword">while</span>(n--) &#123;        fast = fast.next    &#125;    <span class="hljs-comment">// fast、slow 一起前进</span>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast.next) &#123;        fast = fast.next        slow = slow.next    &#125;    slow.next = slow.next.next    <span class="hljs-keyword">return</span> dummyNode.next&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法与逻辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现call、apply</title>
    <link href="/2018/09/25/write-code%20/%E5%AE%9E%E7%8E%B0call%E3%80%81apply/"/>
    <url>/2018/09/25/write-code%20/%E5%AE%9E%E7%8E%B0call%E3%80%81apply/</url>
    
    <content type="html"><![CDATA[<h3 id="实现call"><a href="#实现call" class="headerlink" title="实现call"></a>实现call</h3><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.mycall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> [thisArg, ...args] = [...arguments];    thisArg = <span class="hljs-built_in">Object</span>(thisArg) || <span class="hljs-built_in">window</span>;    <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">Symbol</span>();    thisArg[fn] = <span class="hljs-built_in">this</span>;    <span class="hljs-keyword">let</span> result = thisArg[fn](...args);    <span class="hljs-keyword">delete</span> thisArg[fn];    <span class="hljs-keyword">return</span> result;&#125;;</code></pre><h3 id="实现apply"><a href="#实现apply" class="headerlink" title="实现apply"></a>实现apply</h3><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myapply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> [thisArg, args] = [...arguments];    thisArg = <span class="hljs-built_in">Object</span>(thisArg);    <span class="hljs-keyword">let</span> fn = <span class="hljs-built_in">Symbol</span>();    thisArg[fn] = <span class="hljs-built_in">this</span>;    <span class="hljs-keyword">let</span> result = thisArg[fn](...args);    <span class="hljs-keyword">delete</span> thisArg.fn;    <span class="hljs-keyword">return</span> result;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>手撕代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter</title>
    <link href="/2018/06/01/vue/VueRouter/"/>
    <url>/2018/06/01/vue/VueRouter/</url>
    
    <content type="html"><![CDATA[<h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><ul><li>hash</li><li>history</li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>带＃</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>需要server支持</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> User = &#123;    template:<span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;&#x27;</span>&#125;<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;    routes:[        <span class="hljs-comment">// 动态路径参数 以冒号开头。命中/user/10等格式路由</span>        &#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/user/:id&#x27;</span>,<span class="hljs-attr">component</span>:User&#125;    ]&#125;)</code></pre><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>Vue.use(VueRouter)<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123; routes: [ &#123; path: <span class="hljs-string">&#x27;/&#x27;</span>, name: <span class="hljs-string">&#x27;Navigator&#x27;</span>, component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;navigator&quot; */</span> <span class="hljs-string">&#x27;./../components/Navigator&#x27;</span>) &#125;, &#123; path: <span class="hljs-string">&#x27;/tucao&#x27;</span>, name: <span class="hljs-string">&#x27;Tucao&#x27;</span>, component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;tucao&quot; */</span> <span class="hljs-string">&#x27;./../components/Tucao&#x27;</span>) &#125; ]&#125;)</code></pre><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>路由钩子函数有三种：</p><ol><li><p>全局钩子： beforeEach、 afterEach</p></li><li><p>单个路由里面的钩子： beforeEnter、 beforeLeave</p></li><li><p>组件路由：beforeRouteEnter、 beforeRouteUpdate、 beforeRouteLeave</p></li></ol><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><p>无论访问哪一个路径，都会触发全局的钩子函数，位置是调用router的方法</p><p><strong>router.beforeEach() 进入之前触发</strong></p><p><strong>router.afterEach() 进入之后触发</strong></p><h4 id="beforeEach（全局前置守卫）"><a href="#beforeEach（全局前置守卫）" class="headerlink" title="beforeEach（全局前置守卫）"></a>beforeEach（全局前置守卫）</h4><p>使用 router.beforeEach 注册一个全局前置守卫</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;    ...&#125;)router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>) =&gt;</span> &#123;    <span class="hljs-comment">// do something....   </span>&#125;)</code></pre><p>每个守卫方法接收三个参数：</p><ul><li>to: Route: 即将要进入的目标路由对象（to是一个对象，是将要进入的路由对象，可以用to.path调用路由对象中的属性）</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 这是一个必须需要调用的方法，执行效果依赖 next 方法的调用参数。</li></ul><h5 id="next参数"><a href="#next参数" class="headerlink" title="next参数"></a>next参数</h5><ul><li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed (确认的)。</li><li>next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按 钮)，那么 URL 地址会重置到 from 路由对应的地址。</li><li>next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在router-link 的 to prop或router.push中的选项。</li><li>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给router.onError()注册过的回调。</li></ul><blockquote><p>确保要调用 next 方法，否则钩子就不会被 resolved。</p></blockquote><h4 id="afterEach（全局后置钩子）"><a href="#afterEach（全局后置钩子）" class="headerlink" title="afterEach（全局后置钩子）"></a>afterEach（全局后置钩子）</h4><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;    ...&#125;)router.afterEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span></span>)=&gt;</span>&#123;    <span class="hljs-comment">// do something....   </span>&#125;)</code></pre><p>和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身</p><h4 id="路由独享的守卫-单个路由独享的"><a href="#路由独享的守卫-单个路由独享的" class="headerlink" title="路由独享的守卫(单个路由独享的)"></a>路由独享的守卫(单个路由独享的)</h4><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> VueRouter(&#123;    routes: [        &#123;            path: <span class="hljs-string">&#x27;/&#x27;</span>,            name: <span class="hljs-string">&#x27;Navigator&#x27;</span>,            beforeEnter:(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>)=&gt;</span>&#123;                <span class="hljs-comment">// do something....   </span>            &#125;),            component: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: &quot;navigator&quot; */</span> <span class="hljs-string">&#x27;./../components/Navigator&#x27;</span>)        &#125;    ]&#125;)</code></pre><h4 id="组件级路由钩子"><a href="#组件级路由钩子" class="headerlink" title="组件级路由钩子"></a>组件级路由钩子</h4><pre><code class="hljs stylus">&#123;data,methods<span class="hljs-function"><span class="hljs-title">beforeRouteEnter</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-comment">// this 不指向实例 组件还没创建</span>    next((vm) =&gt;&#123;        <span class="hljs-comment">// vm就是实例</span>    &#125;)&#125;<span class="hljs-function"><span class="hljs-title">beforeRouteUpdate</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// do something....   </span>&#125;<span class="hljs-function"><span class="hljs-title">beforeRouteLeave</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">// do something....   </span>&#125; &#125;</code></pre><p><img src="/images/pages/luyou1.png" alt="image"><br>beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p><p><img src="/images/pages/luyou2.png" alt="image"></p><p>注意~ ： beforeRouteEnter 是支持给 next 传递回调的唯一守卫。对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</p><p>这个离开守卫beforeRouteLeave()通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 next(false) 来取消。</p><p><img src="/images/pages/luyou3.png" alt="image"></p><h4 id="完整的导航解析流程："><a href="#完整的导航解析流程：" class="headerlink" title="完整的导航解析流程："></a>完整的导航解析流程：</h4><ol><li><p>导航被触发。</p></li><li><p>在失活的组件里调用离开守卫。</p></li><li><p>调用全局的 beforeEach 守卫。</p></li><li><p>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</p></li><li><p>在路由配置里调用 beforeEnter。</p></li><li><p>解析异步路由组件。</p></li><li><p>在被激活的组件里调用 beforeRouteEnter。</p></li><li><p>调用全局的 beforeResolve 守卫 (2.5+)。</p></li><li><p>导航被确认。</p></li><li><p>调用全局的 afterEach 钩子。</p></li><li><p>触发 DOM 更新。</p></li><li><p>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>框架、库学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并连续数字</title>
    <link href="/2018/03/20/algorithm/%E5%90%88%E5%B9%B6%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97/"/>
    <url>/2018/03/20/algorithm/%E5%90%88%E5%B9%B6%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>题目描述:</p></blockquote><blockquote><p>输入:[0, 2, 3, 5, 6, 7, 8, 9, 11, 13, 56, 57]</p></blockquote><blockquote><p>输出结果：</p></blockquote><blockquote><p>0,2-3,5-9,11,13,56-57</p></blockquote><p><strong>思路:</strong> 三指针, 同向而行, slow 左边的为处理好的元素, f 指针快速向前走, begin 指针记录区间开始区间, prev 指针记录区间结束位置。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">combine</span>(<span class="hljs-params">arr</span>) </span>&#123;    <span class="hljs-keyword">let</span> f = <span class="hljs-number">1</span>, slow = <span class="hljs-number">0</span>;    <span class="hljs-keyword">let</span> prev = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">while</span> (f &lt; arr.length) &#123;        <span class="hljs-keyword">let</span> begin = f - <span class="hljs-number">1</span>;        prev = arr[begin];        <span class="hljs-keyword">while</span> (f &lt; arr.length &amp;&amp; arr[f] - prev === <span class="hljs-number">1</span>) &#123;            prev = arr[f];            f++;        &#125;        <span class="hljs-keyword">if</span> (f - begin === <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span> (arr[f + <span class="hljs-number">1</span>] - arr[f] !== <span class="hljs-number">1</span>) &#123;                !begin ? arr[slow++] = arr[begin] : arr[slow++] = arr[f];            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (!begin) arr[slow++] = arr[begin];            &#125;            f++;        &#125; <span class="hljs-keyword">else</span> &#123;            arr[slow++] = arr[begin] + <span class="hljs-string">`-`</span> + prev;        &#125;    &#125;    <span class="hljs-keyword">return</span> arr.slice(<span class="hljs-number">0</span>, slow).join(<span class="hljs-string">&#x27;,&#x27;</span>);&#125;<span class="hljs-keyword">let</span> res = combine([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">56</span>, <span class="hljs-number">57</span>]);<span class="hljs-built_in">console</span>.log(res);</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法与逻辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串全排列</title>
    <link href="/2018/03/19/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2018/03/19/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>字符串全排列 [要求 Tc: O(n!) Sc:O(n²)]<br><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 第 38 题</a></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> permutation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;    <span class="hljs-keyword">let</span> solution = [];    <span class="hljs-keyword">if</span> (s.length === <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> solution;    &#125;    permutationHelper(s, solution);    <span class="hljs-keyword">return</span> solution;&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">permutationHelper</span>(<span class="hljs-params">s, solution, used = [], path = []</span>) </span>&#123;    <span class="hljs-keyword">if</span> (path.length === s.length) &#123;        solution.push(path.slice(<span class="hljs-number">0</span>).join(<span class="hljs-string">&#x27;&#x27;</span>));        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">let</span> levelSet = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;        <span class="hljs-keyword">if</span> (!levelSet.has(s[i])) &#123;            <span class="hljs-keyword">if</span> (!used[i]) &#123;                used[i] = <span class="hljs-literal">true</span>;                levelSet.add(s[i]);                path.push(s[i]);                permutationHelper(s, solution, used, path);                used[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">//回溯</span>                path.pop();<span class="hljs-comment">//回到母节点往右走时应该删除添加过的节点,防止保留意外的结果</span>            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法与逻辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串相加</title>
    <link href="/2018/03/19/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
    <url>/2018/03/19/algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-strings/">LeetCode 第 415 题</a></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> addStrings = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;    <span class="hljs-keyword">let</span> res = [];    <span class="hljs-keyword">let</span> i = num1.length - <span class="hljs-number">1</span>, j = num2.length - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">let</span> n1 = i &gt;= <span class="hljs-number">0</span> ? num1.charAt(i) - <span class="hljs-number">0</span>: <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> n2 = j &gt;= <span class="hljs-number">0</span> ? num2.charAt(j) - <span class="hljs-number">0</span>: <span class="hljs-number">0</span>;        <span class="hljs-keyword">let</span> tmp = n1 + n2 + carry;        carry = <span class="hljs-built_in">parseInt</span>(tmp / <span class="hljs-number">10</span>);<span class="hljs-comment">//算出十位数</span>        res.push(tmp % <span class="hljs-number">10</span>);<span class="hljs-comment">//算出个位数</span>        i--; j--;    &#125;    <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>) res.push(<span class="hljs-string">&#x27;1&#x27;</span>);    <span class="hljs-keyword">return</span> res.reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法与逻辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件渲染过程</title>
    <link href="/2018/03/11/vue/Vue%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    <url>/2018/03/11/vue/Vue%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="初次渲染过程"><a href="#初次渲染过程" class="headerlink" title="初次渲染过程"></a>初次渲染过程</h2><ol><li>解析模版为render函数（编译打包时已经完成，开发环境下完成）（vue-loader）</li><li>触发响应式，监听data属性，getter setter</li><li>执行render函数，生成vnode，patch（elem,vnode）</li></ol><h2 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h2><ol><li>修改data，触发setter（此前在getter中已经被监听）</li><li>重新执行render函数，生成newVnode</li><li>patch(vnode,newVnode)</li></ol><h2 id="异步渲染过程"><a href="#异步渲染过程" class="headerlink" title="异步渲染过程"></a>异步渲染过程</h2><ol><li>$nextTick</li><li>汇总data的修改一次性更新视图</li><li>修改DOM操作次数，提升性能</li></ol>]]></content>
    
    
    <categories>
      
      <category>框架、库学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue模板编译</title>
    <link href="/2018/02/28/vue/Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/"/>
    <url>/2018/02/28/vue/Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<h3 id="模版编译"><a href="#模版编译" class="headerlink" title="模版编译"></a>模版编译</h3><ul><li>模版是vue开发中最常用的部分，即与使用相关的原理</li><li>不是html，有指令等</li><li>组件渲染和更新的过程</li></ul><h3 id="js的with语法"><a href="#js的with语法" class="headerlink" title="js的with语法"></a>js的with语法</h3><ul><li>改变{}内自由变量的查找规则，当作obj的属性来查找</li><li>如果找不到匹配的属性，则报错</li><li>with慎用，打破了作用域的规则，易读性差</li></ul><h3 id="vue-template-complier将模版编译为render函数"><a href="#vue-template-complier将模版编译为render函数" class="headerlink" title="vue template complier将模版编译为render函数"></a>vue template complier将模版编译为render函数</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> compiler = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-template-compiler&#x27;</span>)<span class="hljs-comment">// 插值</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;`</span><span class="hljs-comment">// with(this)&#123;return createElement(&#x27;p&#x27;,[createTextVNode(toString(message))])&#125;</span><span class="hljs-comment">// h -&gt; vnode</span><span class="hljs-comment">// createElement -&gt; vnode</span><span class="hljs-comment">// // 表达式</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`&lt;p&gt;&#123;&#123;flag ? message : &#x27;no message found&#x27;&#125;&#125;&lt;/p&gt;`</span><span class="hljs-comment">// // with(this)&#123;return _c(&#x27;p&#x27;,[_v(_s(flag ? message : &#x27;no message found&#x27;))])&#125;</span><span class="hljs-comment">// // 属性和动态属性</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><span class="hljs-string">    &lt;div id=&quot;div1&quot; class=&quot;container&quot;&gt;</span><span class="hljs-string">        &lt;img :src=&quot;imgUrl&quot;/&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">`</span><span class="hljs-comment">// with(this)&#123;return _c(&#x27;div&#x27;,</span><span class="hljs-comment">//      &#123;staticClass:&quot;container&quot;,attrs:&#123;&quot;id&quot;:&quot;div1&quot;&#125;&#125;,</span><span class="hljs-comment">//      [</span><span class="hljs-comment">//          _c(&#x27;img&#x27;,&#123;attrs:&#123;&quot;src&quot;:imgUrl&#125;&#125;)])&#125;</span><span class="hljs-comment">// // 条件</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><span class="hljs-string">    &lt;div&gt;</span><span class="hljs-string">        &lt;p v-if=&quot;flag === &#x27;a&#x27;&quot;&gt;A&lt;/p&gt;</span><span class="hljs-string">        &lt;p v-else-if=&quot;flag === &#x27;b&#x27;&quot;&gt;C&lt;/p&gt;</span><span class="hljs-string">        &lt;p v-else&gt;B&lt;/p&gt;</span><span class="hljs-string">    &lt;/div&gt;</span><span class="hljs-string">`</span><span class="hljs-comment">// with(this)&#123;return _c(&#x27;div&#x27;,[(flag === &#x27;a&#x27;)?_c(&#x27;p&#x27;,[_v(&quot;A&quot;)]):_c(&#x27;p&#x27;,[_v(&quot;B&quot;)])])&#125;</span><span class="hljs-comment">// 循环</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><span class="hljs-string">    &lt;ul&gt;</span><span class="hljs-string">        &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/li&gt;</span><span class="hljs-string">    &lt;/ul&gt;</span><span class="hljs-string">`</span><span class="hljs-comment">// with(this)&#123;return _c(&#x27;ul&#x27;,_l((list),function(item)&#123;return _c(&#x27;li&#x27;,&#123;key:item.id&#125;,[_v(_s(item.title))])&#125;),0)&#125;</span><span class="hljs-comment">// 事件</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`</span><span class="hljs-string">    &lt;button @click=&quot;clickHandler&quot;&gt;submit&lt;/button&gt;</span><span class="hljs-string">`</span><span class="hljs-comment">// with(this)&#123;return _c(&#x27;button&#x27;,&#123;on:&#123;&quot;click&quot;:clickHandler&#125;&#125;,[_v(&quot;submit&quot;)])&#125;</span><span class="hljs-comment">// v-model</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;`</span><span class="hljs-comment">// 主要看 input 事件</span><span class="hljs-comment">// with(this)&#123;return _c(&#x27;input&#x27;,&#123;directives:[&#123;name:&quot;model&quot;,rawName:&quot;v-model&quot;,value:(name),expression:&quot;name&quot;&#125;],attrs:&#123;&quot;type&quot;:&quot;text&quot;&#125;,domProps:&#123;&quot;value&quot;:(name)&#125;,on:&#123;&quot;input&quot;:function($event)&#123;if($event.target.composing)return;name=$event.target.value&#125;&#125;&#125;)&#125;</span><span class="hljs-comment">// render 函数</span><span class="hljs-comment">// 返回 vnode</span><span class="hljs-comment">// patch</span><span class="hljs-comment">// 编译</span><span class="hljs-keyword">const</span> res = compiler.compile(template)<span class="hljs-built_in">console</span>.log(res.render)<span class="hljs-comment">// ---------------分割线--------------</span><span class="hljs-comment">// // 从 vue 源码中找到缩写函数的含义</span><span class="hljs-comment">// function installRenderHelpers (target) &#123;</span><span class="hljs-comment">//     target._o = markOnce;</span><span class="hljs-comment">//     target._n = toNumber;</span><span class="hljs-comment">//     target._s = toString;</span><span class="hljs-comment">//     target._l = renderList;</span><span class="hljs-comment">//     target._t = renderSlot;</span><span class="hljs-comment">//     target._q = looseEqual;</span><span class="hljs-comment">//     target._i = looseIndexOf;</span><span class="hljs-comment">//     target._m = renderStatic;</span><span class="hljs-comment">//     target._f = resolveFilter;</span><span class="hljs-comment">//     target._k = checkKeyCodes;</span><span class="hljs-comment">//     target._b = bindObjectProps;</span><span class="hljs-comment">//     target._v = createTextVNode;</span><span class="hljs-comment">//     target._e = createEmptyVNode;</span><span class="hljs-comment">//     target._u = resolveScopedSlots;</span><span class="hljs-comment">//     target._g = bindObjectListeners;</span><span class="hljs-comment">//     target._d = bindDynamicKeys;</span><span class="hljs-comment">//     target._p = prependModifier;</span><span class="hljs-comment">// &#125;</span></code></pre><h3 id="执行render-生成-vnode"><a href="#执行render-生成-vnode" class="headerlink" title="执行render 生成 vnode"></a>执行render 生成 vnode</h3><p>执行render函数生成vnode</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>模版编译为render函数，执行render函数返回vnode</li><li>基于vonde再执行patch和diff</li><li>使用webpack vue-loader，会在开发环境下编译模版</li><li>可以使用render代替template</li></ul>]]></content>
    
    
    <categories>
      
      <category>框架、库学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue的数据劫持</title>
    <link href="/2018/02/16/vue/Vue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81/"/>
    <url>/2018/02/16/vue/Vue%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<h3 id="Object-defineProperty-obj-prop-desc"><a href="#Object-defineProperty-obj-prop-desc" class="headerlink" title="Object.defineProperty(obj, prop, desc)"></a>Object.defineProperty(obj, prop, desc)</h3><p><strong>核心的API</strong></p><h3 id="监听对象（简单）"><a href="#监听对象（简单）" class="headerlink" title="监听对象（简单）"></a>监听对象（简单）</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;&#125;<span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;zhangsan&#x27;</span><span class="hljs-built_in">Object</span>.defineProperty(data, <span class="hljs-string">&#x27;name&#x27;</span> ,&#123;    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;get &#x27;</span>+name)        <span class="hljs-keyword">return</span> name    &#125;,    set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;set &#x27;</span>+value)        name = value     &#125;&#125;)</code></pre><h3 id="复杂对象监听"><a href="#复杂对象监听" class="headerlink" title="复杂对象监听"></a>复杂对象监听</h3><h4 id="线程上的代码"><a href="#线程上的代码" class="headerlink" title="线程上的代码"></a>线程上的代码</h4><pre><code class="hljs js"><span class="hljs-comment">// 准备数据</span><span class="hljs-keyword">const</span> data = &#123;    name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,    age: <span class="hljs-number">20</span>,    info: &#123;        address: <span class="hljs-string">&#x27;北京&#x27;</span> <span class="hljs-comment">// 需要深度监听</span>    &#125;,    nums: [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]&#125;<span class="hljs-comment">// 监听数据</span>observer(data)<span class="hljs-comment">// 测试</span>data.name = <span class="hljs-string">&#x27;lisi&#x27;</span>data.age = <span class="hljs-number">21</span></code></pre><h4 id="observer方法"><a href="#observer方法" class="headerlink" title="observer方法"></a>observer方法</h4><pre><code class="hljs js"><span class="hljs-comment">// 监听对象属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observer</span>(<span class="hljs-params">target</span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target === <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 不是对象或数组</span>        <span class="hljs-keyword">return</span> target    &#125;    <span class="hljs-comment">// 重新定义各个属性（for in 也可以遍历数组）</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> target) &#123;        defineReactive(target, key, target[key])    &#125;&#125;</code></pre><h4 id="defineReactive方法"><a href="#defineReactive方法" class="headerlink" title="defineReactive方法"></a>defineReactive方法</h4><pre><code class="hljs js"><span class="hljs-comment">// 重新定义属性，监听起来</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">target, key, value</span>) </span>&#123;    <span class="hljs-comment">// 深度监听</span>    observer(value)    <span class="hljs-comment">// 核心 API</span>    <span class="hljs-built_in">Object</span>.defineProperty(target, key, &#123;        get() &#123;            <span class="hljs-keyword">return</span> value        &#125;,        set(newValue) &#123;            <span class="hljs-keyword">if</span> (newValue !== value) &#123;                <span class="hljs-comment">// 深度监听</span>                observer(newValue)                <span class="hljs-comment">// 设置新值</span>                <span class="hljs-comment">// 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值</span>                value = newValue                <span class="hljs-comment">// 触发更新视图</span>                updateView()            &#125;        &#125;    &#125;)&#125;</code></pre><blockquote><p>此处使用递归的形式，进行对象的向下遍历</p></blockquote><h4 id="Object-defineProperty的缺点"><a href="#Object-defineProperty的缺点" class="headerlink" title="Object.defineProperty的缺点"></a>Object.defineProperty的缺点</h4><ul><li>深度监听，需要一次性递归到底，计算量大</li><li>无法监听新增/删除属性（所以使用Vue的set和delete方法）</li><li>无法监听原生数组，需要特殊处理</li></ul><h3 id="数组监听"><a href="#数组监听" class="headerlink" title="数组监听"></a>数组监听</h3><h4 id="对数组进行重新定义"><a href="#对数组进行重新定义" class="headerlink" title="对数组进行重新定义"></a>对数组进行重新定义</h4><pre><code class="hljs js"><span class="hljs-comment">// 重新定义数组原型</span><span class="hljs-keyword">const</span> oldArrayProperty = <span class="hljs-built_in">Array</span>.prototype<span class="hljs-comment">// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型</span><span class="hljs-keyword">const</span> arrProto = <span class="hljs-built_in">Object</span>.create(oldArrayProperty);[<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-string">&#x27;pop&#x27;</span>, <span class="hljs-string">&#x27;shift&#x27;</span>, <span class="hljs-string">&#x27;unshift&#x27;</span>, <span class="hljs-string">&#x27;splice&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-params">methodName</span> =&gt;</span> &#123;    arrProto[methodName] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        updateView() <span class="hljs-comment">// 触发视图更新</span>        <span class="hljs-comment">// 在执行updateView后，任然能够继续执行数组对象原有的方法</span>        oldArrayProperty[methodName].call(<span class="hljs-built_in">this</span>, ...arguments)        <span class="hljs-comment">// 污染全局</span>        <span class="hljs-comment">// Array.prototype.push.call(this, ...arguments)</span>    &#125;&#125;)</code></pre><h4 id="修改observer"><a href="#修改observer" class="headerlink" title="修改observer"></a>修改observer</h4><pre><code class="hljs js"><span class="hljs-comment">// 监听对象属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observer</span>(<span class="hljs-params">target</span>) </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target === <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 不是对象或数组</span>        <span class="hljs-keyword">return</span> target    &#125;    <span class="hljs-comment">// 污染全局的 Array 原型</span>    <span class="hljs-comment">// Array.prototype.push = function () &#123;</span>    <span class="hljs-comment">//     updateView()</span>    <span class="hljs-comment">//     ...</span>    <span class="hljs-comment">// &#125;</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(target)) &#123;        target.__proto__ = arrProto    &#125;    <span class="hljs-comment">// 重新定义各个属性（for in 也可以遍历数组）</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> target) &#123;        defineReactive(target, key, target[key])    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>框架、库学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单向链表翻转</title>
    <link href="/2018/02/07/algorithm/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/"/>
    <url>/2018/02/07/algorithm/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<p>反转单链表 [要求 Tc: O(n) Sc:O(1)] </p><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">剑指 Offer 第 24 题</a></p><h3 id="迭代解法-从左到右反转"><a href="#迭代解法-从左到右反转" class="headerlink" title="迭代解法 (从左到右反转):"></a><strong>迭代解法 (从左到右反转):</strong></h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span> || head.next === <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>, cur = head;    <span class="hljs-keyword">while</span> (cur !== <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">let</span> next = cur.next;        cur.next = pre;        pre = cur;        cur = next;    &#125;    <span class="hljs-keyword">return</span> pre;&#125;;</code></pre><h3 id="递归解法-从右往左反转"><a href="#递归解法-从右往左反转" class="headerlink" title="递归解法:(从右往左反转)"></a><strong>递归解法:(从右往左反转)</strong></h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseList = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;    <span class="hljs-keyword">if</span>(head === <span class="hljs-literal">null</span> || head.next === <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-keyword">let</span> newHead = reverseList(head.next);    head.next.next = head;    head.next = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> newHead;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法与逻辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础二</title>
    <link href="/2018/01/22/vue/Vue%E5%9F%BA%E7%A1%80%E4%BA%8C/"/>
    <url>/2018/01/22/vue/Vue%E5%9F%BA%E7%A1%80%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础学习笔记"><a href="#Vue基础学习笔记" class="headerlink" title="Vue基础学习笔记"></a>Vue基础学习笔记</h1><h2 id="循环渲染"><a href="#循环渲染" class="headerlink" title="循环渲染"></a>循环渲染</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>遍历数组<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in listArr&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>                &#123;&#123;index&#125;&#125; - &#123;&#123;item.id&#125;&#125; - &#123;&#123;item.title&#125;&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>遍历对象<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> &gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(val, key, index) in listObj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;key&quot;</span>&gt;</span>                &#123;&#123;index&#125;&#125; - &#123;&#123;key&#125;&#125; -  &#123;&#123;val.title&#125;&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            flag: <span class="hljs-literal">false</span>,</span>            listArr: [<span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题1&#x27;</span> &#125;, <span class="hljs-comment">// 数据结构中，最好有 id ，方便使用 key</span></span><span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题2&#x27;</span> &#125;,</span><span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题3&#x27;</span> &#125;</span>            ],            listObj: &#123;<span class="javascript">                a: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题1&#x27;</span> &#125;,</span><span class="javascript">                b: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题2&#x27;</span> &#125;,</span><span class="javascript">                c: &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题3&#x27;</span> &#125;,</span>            &#125;        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><ul><li>v-for不光能遍历数组，也可以遍历对象</li><li>v-for和v-if不能同时使用</li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment1&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment2(2, $event)&quot;</span>&gt;</span>+2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span>            num: 0        &#125;    &#125;,    methods: &#123;        increment1(event) &#123;<span class="javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;event&#x27;</span>, event, event.__proto__.constructor) <span class="hljs-comment">// 是原生的 event 对象</span></span><span class="javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><span class="javascript">            <span class="hljs-built_in">console</span>.log(event.target)</span><span class="javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><span class="javascript">            <span class="hljs-built_in">console</span>.log(event.currentTarget) <span class="hljs-comment">// 注意，事件是被注册到当前元素的，和 React 不一样</span></span><span class="javascript">            <span class="hljs-built_in">this</span>.num++</span><span class="javascript">            <span class="hljs-comment">// 1. event 是原生的</span></span><span class="javascript">            <span class="hljs-comment">// 2. 事件被挂载到当前元素</span></span><span class="javascript">            <span class="hljs-comment">// 和 DOM 事件一样</span></span>        &#125;,        increment2(val, event) &#123;<span class="javascript">            <span class="hljs-comment">// eslint-disable-next-line</span></span><span class="javascript">            <span class="hljs-built_in">console</span>.log(event.target)</span><span class="javascript">            <span class="hljs-built_in">this</span>.num = <span class="hljs-built_in">this</span>.num + val</span>        &#125;,        loadHandler() &#123;<span class="javascript">            <span class="hljs-comment">// do some thing</span></span>        &#125;    &#125;,    mounted() &#123;<span class="javascript">        <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-built_in">this</span>.loadHandler)</span>    &#125;,    beforeDestroy() &#123;<span class="javascript">        <span class="hljs-comment">//【注意】用 vue 绑定的事件，组建销毁时会自动被解绑</span></span><span class="javascript">        <span class="hljs-comment">// 自己绑定的事件，需要自己销毁！！！</span></span><span class="javascript">        <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-built_in">this</span>.loadHandler)</span>    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>输入框: &#123;&#123;name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;age&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>多行文本: &#123;&#123;desc&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 注意，&lt;textarea&gt;&#123;&#123;desc&#125;&#125;&lt;/textarea&gt; 是不允许的！！！ --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>复选框 &#123;&#123;checked&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checked&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>多个复选框 &#123;&#123;checkedNames&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jack&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span>Jack<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;John&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mike&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Mike&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mike&quot;</span>&gt;</span>Mike<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>单选 &#123;&#123;gender&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;gender&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>下拉列表选择 &#123;&#123;selected&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>下拉列表选择（多选） &#123;&#123;selectedList&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selectedList&quot;</span> <span class="hljs-attr">multiple</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">disabled</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            name: <span class="hljs-string">&#x27;双越&#x27;</span>,</span>            age: 18,<span class="javascript">            desc: <span class="hljs-string">&#x27;自我介绍&#x27;</span>,</span><span class="javascript">            checked: <span class="hljs-literal">true</span>,</span>            checkedNames: [],<span class="javascript">            gender: <span class="hljs-string">&#x27;male&#x27;</span>,</span><span class="javascript">            selected: <span class="hljs-string">&#x27;&#x27;</span>,</span>            selectedList: []        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>框架、库学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础一</title>
    <link href="/2018/01/20/vue/Vue%E5%9F%BA%E7%A1%80%E4%B8%80/"/>
    <url>/2018/01/20/vue/Vue%E5%9F%BA%E7%A1%80%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue基础学习笔记"><a href="#Vue基础学习笔记" class="headerlink" title="Vue基础学习笔记"></a>Vue基础学习笔记</h1><h2 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>文本插值 &#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>JS 表达式 &#123;&#123; flag ? &#x27;yes&#x27; : &#x27;no&#x27; &#125;&#125; （只能是表达式，不能是 js 语句）<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span>动态属性 id<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>有 xss 风险<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>【注意】使用 v-html 之后，将会覆盖子元素<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 其他常用指令后面讲 --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            message: <span class="hljs-string">&#x27;hello vue&#x27;</span>,</span><span class="javascript">            flag: <span class="hljs-literal">true</span>,</span><span class="handlebars"><span class="xml">            rawHtml: &#x27;指令 - 原始 html <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>加粗<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>斜体<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>&#x27;,</span></span><span class="javascript">            dynamicId: <span class="hljs-string">`id-<span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()&#125;</span>`</span></span>        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h2 id="computed和watch"><a href="#computed和watch" class="headerlink" title="computed和watch"></a>computed和watch</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>一个计算属性,类似于过滤器,对绑定到view的数据进行处理。</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data: &#123;        firstName: <span class="hljs-string">&#x27;Foo&#x27;</span>,        lastName: <span class="hljs-string">&#x27;Bar&#x27;</span>    &#125;,    computed: &#123;        fullName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName        &#125;    &#125;&#125;</code></pre><p><strong>fullName不可在data里面定义</strong></p><h4 id="get和set用法"><a href="#get和set用法" class="headerlink" title="get和set用法"></a>get和set用法</h4><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data: &#123;        firstName: <span class="hljs-string">&#x27;Foo&#x27;</span>,        lastName: <span class="hljs-string">&#x27;Bar&#x27;</span>    &#125;,    computed: &#123;        fullName:&#123;            get()&#123;<span class="hljs-comment">//回调函数 当需要读取当前属性值是执行，根据相关数据计算并返回当前属性的值</span>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName            &#125;,            set(val)&#123;<span class="hljs-comment">//监视当前属性值的变化，当属性值发生变化时执行，更新相关的属性数据</span>                <span class="hljs-comment">//val就是fullName的最新属性值</span>                <span class="hljs-built_in">console</span>.log(val)                <span class="hljs-keyword">const</span> names = val.split(<span class="hljs-string">&#x27; &#x27;</span>);                <span class="hljs-built_in">console</span>.log(names)                <span class="hljs-built_in">this</span>.firstName = names[<span class="hljs-number">0</span>];                <span class="hljs-built_in">this</span>.lastName = names[<span class="hljs-number">1</span>];            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>computed有缓存，data不变则不会重新计算</strong></p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>watch是一个观察的动作</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data: &#123;        firstName: <span class="hljs-string">&#x27;Foo&#x27;</span>,        lastName: <span class="hljs-string">&#x27;Bar&#x27;</span>,        fullName: <span class="hljs-string">&#x27;Foo Bar&#x27;</span>    &#125;,    watch: &#123;        firstName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;            <span class="hljs-built_in">this</span>.fullName = val + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName        &#125;,        lastName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;            <span class="hljs-built_in">this</span>.fullName = <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + val        &#125;    &#125;&#125;</code></pre><h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data() &#123;        <span class="hljs-keyword">return</span>&#123;            <span class="hljs-string">&#x27;first&#x27;</span>:<span class="hljs-number">2</span>        &#125;    &#125;,    watch: &#123;        first()&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.first)        &#125;    &#125;,&#125;</code></pre><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data()&#123;        <span class="hljs-keyword">return</span>&#123;            <span class="hljs-string">&#x27;first&#x27;</span>:&#123;                second:<span class="hljs-number">0</span>            &#125;        &#125;    &#125;,    watch:&#123;        secondChange:&#123;            handler(oldVal,newVal)&#123;                <span class="hljs-built_in">console</span>.log(oldVal)                <span class="hljs-built_in">console</span>.log(newVal)            &#125;,            deep:<span class="hljs-literal">true</span>        &#125;    &#125;&#125;</code></pre><ul><li><p><strong>console.log打印的结果,发现oldVal和newVal值是一样的,所以深度监听虽然可以监听到对象的变化,但是无法监听到具体对象里面那个属性的变化（只针对引用类型）</strong></p></li><li><p>oldVal和newVal值一样的原因是它们索引同一个对象/数组。Vue <strong>不会保留修改之前值的副本</strong></p></li><li><p>深度监听对应的函数名必须为handler,否则无效果,因为watcher里面对应的是对handler的调用</p></li></ul><h4 id="监听对象单个属性"><a href="#监听对象单个属性" class="headerlink" title="监听对象单个属性"></a>监听对象单个属性</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data() &#123;        <span class="hljs-keyword">return</span> &#123;            first: &#123;                second: <span class="hljs-number">0</span>            &#125;        &#125;;    &#125;,    watch: &#123;        <span class="hljs-string">&quot;first.second&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newVal, oldVal</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(newVal, oldVal);        &#125;    &#125;&#125;</code></pre><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>用computed作为中间件转化,因为computed可以取到对应的属性值</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;    data() &#123;        <span class="hljs-keyword">return</span> &#123;            first: &#123;                second: <span class="hljs-number">0</span>                &#125;            &#125;;    &#125;,    computed: &#123;        secondChange() &#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.first.second;        &#125;    &#125;,    watch: &#123;        secondChange() &#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;second属性值变化了&quot;</span>);        &#125;    &#125;&#125;</code></pre><h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><h4 id="computed特性"><a href="#computed特性" class="headerlink" title="computed特性"></a>computed特性</h4><ol><li>是计算值</li><li>应用：就是简化tempalte里面双花括号计算和处理props或$emit的传值</li><li>具有缓存性，页面重新渲染值不变化,计算属性会立即返回之前的计算结果，而不必再次执行函数</li></ol><h4 id="watch特性"><a href="#watch特性" class="headerlink" title="watch特性"></a>watch特性</h4><ol><li>是观察的动作</li><li>应用：监听props，$emit或本组件的值执行异步操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ol><h2 id="class和style"><a href="#class和style" class="headerlink" title="class和style"></a>class和style</h2><ul><li>使用动态属性</li><li>使用驼峰式写法</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; black: isBlack, yellow: isYellow &#125;&quot;</span>&gt;</span>使用 class<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[black, yellow]&quot;</span>&gt;</span>使用 class （数组）<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleData&quot;</span>&gt;</span>使用 style<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            isBlack: <span class="hljs-literal">true</span>,</span><span class="javascript">            isYellow: <span class="hljs-literal">true</span>,</span><span class="javascript">            black: <span class="hljs-string">&#x27;black&#x27;</span>,</span><span class="javascript">            yellow: <span class="hljs-string">&#x27;yellow&#x27;</span>,</span>            styleData: &#123;<span class="javascript">                fontSize: <span class="hljs-string">&#x27;40px&#x27;</span>, <span class="hljs-comment">// 转换为驼峰式</span></span><span class="javascript">                color: <span class="hljs-string">&#x27;red&#x27;</span>,</span><span class="javascript">                backgroundColor: <span class="hljs-string">&#x27;#ccc&#x27;</span> <span class="hljs-comment">// 转换为驼峰式</span></span>            &#125;        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css">    <span class="hljs-selector-class">.black</span> &#123;</span><span class="css">        <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#999</span>;</span>    &#125;<span class="css">    <span class="hljs-selector-class">.yellow</span> &#123;</span>        color: yellow;    &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;a&#x27;&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;b&#x27;&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>other<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;type === &#x27;a&#x27;&quot;</span>&gt;</span>A by v-show<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;type === &#x27;b&#x27;&quot;</span>&gt;</span>B by v-show<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>    data() &#123;<span class="javascript">        <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">            type: <span class="hljs-string">&#x27;a&#x27;</span></span>        &#125;    &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h4 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h4><ul><li>v-if是false时候不会渲染dom，v-show则是display:none</li><li>频繁切换使用v-show,不会频繁渲染dom</li></ul>]]></content>
    
    
    <categories>
      
      <category>框架、库学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RainbowSort</title>
    <link href="/2017/11/09/algorithm/RainbowSort/"/>
    <url>/2017/11/09/algorithm/RainbowSort/</url>
    
    <content type="html"><![CDATA[<p>给定一系列球，其中球的颜色只能是红色，黄色或蓝色，对球进行排序，以使所有红色球都分组在左侧，所有黄色球都分组在中间，所有蓝色球分组在右侧。<br>[要求 Tc: O(n) Sc:O(1)]<br>例：</p><blockquote><p>[红] 被排序为 [红]</p></blockquote><blockquote><p>[黄，红] 被排序为 [红，黄]</p></blockquote><blockquote><p>[黄, 红, 红, 蓝, 黄, 红, 蓝] 被排序为 [红, 红, 红, 黄, 黄, 蓝, 蓝]</p></blockquote><p>假设条件:</p><blockquote><p>输入数组不为 null。</p></blockquote><p>corner case:</p><p>如果输入数组的长度为零怎么办？在这种情况下，我们应该直接返回空数组。</p><p><strong>解法：</strong></p><p><strong>思路:</strong> 本题思路是挡板思想, 使用三个挡板四个区域的思想进行划分 (交换数组元素位置)</p><p><strong>挡板的物理意义: [0-i) 全是红色,[i,j) 之间为黄色,(k-&gt;n-1] 全为蓝色，[j-k] 为未知探索区域</strong></p><p>j 为快指针</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = [<span class="hljs-string">&#x27;黄&#x27;</span>, <span class="hljs-string">&#x27;红&#x27;</span>, <span class="hljs-string">&#x27;红&#x27;</span>, <span class="hljs-string">&#x27;蓝&#x27;</span>, <span class="hljs-string">&#x27;黄&#x27;</span>, <span class="hljs-string">&#x27;红&#x27;</span>, <span class="hljs-string">&#x27;蓝&#x27;</span>];<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rainbowSort</span>(<span class="hljs-params">rainbow</span>) </span>&#123;    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = rainbow.length - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (j &lt;= k) &#123;        <span class="hljs-keyword">if</span> (rainbow[j] === <span class="hljs-string">&#x27;红&#x27;</span>) &#123;            swap(rainbow, i, j);            i++;            j++;        &#125;        <span class="hljs-keyword">if</span> (rainbow[j] === <span class="hljs-string">&#x27;黄&#x27;</span>) &#123;            j++;        &#125;        <span class="hljs-keyword">if</span> (rainbow[j] === <span class="hljs-string">&#x27;蓝&#x27;</span>) &#123;            swap(rainbow, j, k); <span class="hljs-comment">//这里不写j++是因为从k交换过来的元素不能保证就是黄色,为了安全起见下次循环再检查一次j位置。</span>            k--;        &#125;    &#125;&#125;<span class="hljs-comment">//辅助交换函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">swap</span>(<span class="hljs-params">arr, i, j</span>) </span>&#123;    [arr[i], arr[j]] = [arr[j], arr[i]];&#125;rainbowSort(input);</code></pre><p>利用sort：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = [<span class="hljs-string">&#x27;黄&#x27;</span>, <span class="hljs-string">&#x27;红&#x27;</span>, <span class="hljs-string">&#x27;红&#x27;</span>, <span class="hljs-string">&#x27;蓝&#x27;</span>, <span class="hljs-string">&#x27;黄&#x27;</span>, <span class="hljs-string">&#x27;红&#x27;</span>, <span class="hljs-string">&#x27;蓝&#x27;</span>];<span class="hljs-keyword">const</span> enums = &#123;    <span class="hljs-string">&#x27;红&#x27;</span>: <span class="hljs-number">1</span>,    <span class="hljs-string">&#x27;黄&#x27;</span>: <span class="hljs-number">2</span>,    <span class="hljs-string">&#x27;蓝&#x27;</span>: <span class="hljs-number">3</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rainbowSort</span>(<span class="hljs-params">rainbow</span>) </span>&#123;    <span class="hljs-keyword">return</span> rainbow.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;        <span class="hljs-keyword">return</span> enums[a] - enums[b];    &#125;);&#125;rainbowSort(input);</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法与逻辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现new、bind、instanceOf、deepClone</title>
    <link href="/2017/08/21/write-code%20/%E5%AE%9E%E7%8E%B0new%E3%80%81bind%E3%80%81instanceOf%E3%80%81deepClone/"/>
    <url>/2017/08/21/write-code%20/%E5%AE%9E%E7%8E%B0new%E3%80%81bind%E3%80%81instanceOf%E3%80%81deepClone/</url>
    
    <content type="html"><![CDATA[<h3 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h3><pre><code class="hljs js"><span class="hljs-keyword">var</span> New = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Fn</span>) </span>&#123;  <span class="hljs-keyword">var</span> obj = &#123;&#125;; <span class="hljs-comment">// 创建空对象</span>  <span class="hljs-keyword">var</span> arg = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);  obj.__proto__ = Fn.prototype; <span class="hljs-comment">// 将obj的原型链__proto__指向构造函数的原型prototype</span>  obj.__proto__.constructor = Fn; <span class="hljs-comment">// 在原型链 __proto__上设置构造函数的构造器constructor，为了实例化Fn</span>  Fn.apply(obj, arg); <span class="hljs-comment">// 执行Fn，并将构造函数Fn执行obj</span>  <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 返回结果</span>&#125;;</code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.bind2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;...&quot;</span>);  &#125;  <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">var</span> args1 = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);  <span class="hljs-keyword">var</span> bindFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> args2 = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);    <span class="hljs-keyword">var</span> that2 = <span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> bindFn ? <span class="hljs-built_in">this</span> : context; <span class="hljs-comment">// 如果当前函数的this指向的是构造函数中的this 则判定为new 操作。如果this是构造函数bindFn new出来的实例，那么此处的this一定是该实例本身。</span>    <span class="hljs-keyword">return</span> that.apply(that2, args1.concat(args2));  &#125;;  <span class="hljs-keyword">var</span> Fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;; <span class="hljs-comment">// 连接原型链用Fn</span>  <span class="hljs-comment">// 原型赋值</span>  Fn.prototype = <span class="hljs-built_in">this</span>.prototype; <span class="hljs-comment">// bindFn的prototype指向和this的prototype一样，指向同一个原型对象</span>  bindFn.prototype = <span class="hljs-keyword">new</span> Fn();  <span class="hljs-keyword">return</span> bindFn;&#125;;</code></pre><h3 id="instanceOf"><a href="#instanceOf" class="headerlink" title="instanceOf"></a>instanceOf</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> instanceOf = <span class="hljs-function">(<span class="hljs-params">left, right</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> proto = left.__proto__;  <span class="hljs-keyword">let</span> prototype = right.prototype;  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span> (proto === <span class="hljs-literal">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (proto === prototype) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    proto = proto.__proto__;  &#125;&#125;;</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> getType = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-comment">// 获取数据类型</span>  <span class="hljs-keyword">const</span> baseType = <span class="hljs-built_in">Object</span>.prototype.toString    .call(data)    .replace(<span class="hljs-regexp">/^\[object\s(.+)\]$/g</span>, <span class="hljs-string">&quot;$1&quot;</span>)    .toLowerCase();  <span class="hljs-keyword">const</span> type = data <span class="hljs-keyword">instanceof</span> Element ? <span class="hljs-string">&quot;element&quot;</span> : baseType;  <span class="hljs-keyword">return</span> type;&#125;;<span class="hljs-keyword">const</span> isPrimitive = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-comment">// 判断是否是基本数据类型</span>  <span class="hljs-keyword">const</span> primitiveType = <span class="hljs-string">&quot;undefined,null,boolean,string,symbol,number,bigint,map,set,weakmap,weakset&quot;</span>.split(    <span class="hljs-string">&quot;,&quot;</span>  ); <span class="hljs-comment">// 其实还有很多类型</span>  <span class="hljs-keyword">return</span> primitiveType.includes(getType(data));&#125;;<span class="hljs-keyword">const</span> isObject = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> getType(data) === <span class="hljs-string">&quot;object&quot;</span>;<span class="hljs-keyword">const</span> isArray = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> getType(data) === <span class="hljs-string">&quot;array&quot;</span>;<span class="hljs-keyword">const</span> deepClone = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-keyword">let</span> cache = &#123;&#125;; <span class="hljs-comment">// 缓存值，防止循环引用</span>  <span class="hljs-keyword">const</span> baseClone = <span class="hljs-function"><span class="hljs-params">_data</span> =&gt;</span> &#123;    <span class="hljs-keyword">let</span> res;    <span class="hljs-keyword">if</span> (isPrimitive(_data)) &#123;      <span class="hljs-keyword">return</span> data;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(_data)) &#123;      res = &#123; ..._data &#125;;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isArray(_data)) &#123;      res = [..._data];    &#125;    <span class="hljs-comment">// 判断是否有复杂类型的数据，有就递归</span>    <span class="hljs-built_in">Reflect</span>.ownKeys(res).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (res[key] &amp;&amp; getType(res[key]) === <span class="hljs-string">&quot;object&quot;</span>) &#123;        <span class="hljs-comment">// 用cache来记录已经被复制过的引用地址。用来解决循环引用的问题</span>        <span class="hljs-keyword">if</span> (cache[res[key]]) &#123;          res[key] = cache[res[key]];        &#125; <span class="hljs-keyword">else</span> &#123;          cache[res[key]] = res[key];          res[key] = baseClone(res[key]);        &#125;      &#125;    &#125;);    <span class="hljs-keyword">return</span> res;  &#125;;  <span class="hljs-keyword">return</span> baseClone(data);&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>手撕代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2017/08/18/basic/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2017/08/18/basic/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>现在让我们深入了解 Flexbox 的缩放 – 以及如何利用它来构建漂亮的自适应布局。</p><a id="more"></a><h3 id="属性-1-Flex-Basis"><a href="#属性-1-Flex-Basis" class="headerlink" title="属性 #1: Flex-Basis"></a>属性 #1: Flex-Basis</h3><p>在上一篇文章中，我们主要了解了适用于容器元素的属性。这一次，我们专门介绍如何控制子元素 (flex 项) 的大小。</p><p>我想，我们这次介绍的第一个属性是 Flexbox 教程中最不好解释的属性之一。</p><p>但 – 不要担心。 它实际上很简单。</p><p><code>flex-basis</code> 控制一个子元素 (flex 项) 的默认大小，但是它可以被其他的 Flexbox 属性影响（稍后详细介绍）。</p><p>在下面的 GIF 中，你会发现它可以与 <code>width</code> 属性互换（等价）：</p><p><img src="/images/pages/IM2.gif" alt="image"></p><p>然而，flex-basis 和 width 有什么不同呢？<code>flex-basis</code> 对应于 flex 轴线而言的：</p><p><img src="/images/pages/IM3.png" alt="image"></p><p>flex-basis 影响元素在主轴 (main axis) 上的大小。</p><p>让我们看看当保持 flex-basis 不变的情况下，改变主轴方向，会发生什么。</p><p><img src="/images/pages/IM4.gif" alt="image"></p><p>注意，我们必须从手动将 <code>height</code> 切换到设置 <code>width</code> 属性。 因此，<code>flex-basis</code> 是根据 <code>flex-direction</code> 的不同来确定 <code>width</code> 或 <code>height</code> 的。</p><h3 id="属性-2-Flex-Grow（拉伸）"><a href="#属性-2-Flex-Grow（拉伸）" class="headerlink" title="属性 #2: Flex Grow（拉伸）"></a>属性 #2: Flex Grow（拉伸）</h3><p>现在我们要更复杂一点了。</p><p>首先，让我们将所有的矩形子元素 (flex 项) 设置为相同的<code>width</code>，120px：</p><p><img src="/images/pages/IM5.png" alt="image"></p><p>现在，涉及到名为 <code>flex-grow</code> 的属性，其默认值为 <code>0</code> 。这意味着矩形子元素 (flex 项) 不允许自动占据容器中剩余的空间。</p><p>这意味着什么呢？好吧，让我们尝试把为每个矩形子元素 (flex 项) 的<code>flex-grow</code>设置为<code>1</code>：</p><p><img src="/images/pages/IMG6.png" alt="image"></p><p>所有矩形子元素 (flex 项) 共同占据了整个容器的宽度，它们之间的间隔也都是均匀分布。<code>flex-grow</code> 值覆盖了 <code>width</code> 值。</p><p>然而，关于 <code>flex-grow</code> 令人困惑的是其值实际上意味着什么呢？<code>flex-grow: 1</code>是什么意思呢？</p><p>嗯，如果设置每个矩形子元素 (flex 项) 的 <code>flex-grow</code> 属性值为 <code>999</code> ，让我们来看一下效果：</p><p><img src="/images/pages/IMG7.png" alt="image"></p><p>正如你所看到的，完全一样。</p><p>这是因为 <code>flex-grow</code> 不是绝对值 – 它是一个相对值。</p><p>对于每个矩形子元素 (flex 项) 来说，重要的不是其 <code>flex-grow</code> 值有多大，而是这个值与其他矩形子元素 (flex 项) 的 <code>flex-grow</code> 值相比较，相对值有多大。</p><p>如果我们将每个矩形子元素 (flex 项) 设置为<code>flex-grow: 1</code>，然后调整第 3 个矩形子元素的<code>flex-grow</code>值，那么我们可以看到改变，如图：</p><p><img src="/images/pages/IMG8.gif" alt="image"></p><p>要真正理解这里到底发生了什么，让我们快速过一边简单的数学知识。</p><p>每个矩形子元素 (flex 项) 的 <code>flex-grow</code> 初始值都是 <code>1</code>。如果我们将每个矩形子元素 (flex 项) 的 <code>flex-grow</code> 相加起来，总和为 <code>6</code>。因此容器的总宽度被平均分成了 6 份。每个矩形子元素 (flex 项) 增长到填充容器可用空间的 1/6。</p><p>当我们将第 3 个矩形子元素的 <code>flex-grow</code> 设置为 <code>2</code> 时，容器现在被分成了 7 等份，因为所有 <code>flex-grow</code> 属性是：1 + 1 + 2 + 1 + 1 + 1。</p><p>第 3 个矩形子元素占了整个容器空间的 2/7，其他的占了 1/7。</p><p>同理，当设置第 3 个矩形子元素的 <code>flex-grow: 3</code> 的时候，整个容器宽度被分成了 8 等份（1 + 1 + 3 + 1 + 1 + 1），第 3 个矩形子元素占了 3/8，其他的占了 1/8。</p><p>以此类推。</p><p><code>flex-grow</code> 只和比例相关，如果我们设置第 3 个矩形子元素 <code>flex-grow: 12</code>，其余每个方块的 <code>flex-grow: 4</code>；跟第三个设置成 3，其他的设置成 1 得到同样的效果，见下图：</p><p><img src="/images/pages/IMG9.png" alt="image"></p><p>重要的是每个矩形子元素的 <code>flex-grow</code> 与其他矩形子元素成比例的。</p><p>最后一点，请记住，就像 <code>flex-basis</code> 一样，<code>flex-grow</code> 只适用于主轴 (main axis)。我们的矩形子元素只会影响宽度，除非我们将 <code>flex-direction</code>设置为<code>column</code>。</p><h3 id="属性-3-Flex-Shrink（收缩）"><a href="#属性-3-Flex-Shrink（收缩）" class="headerlink" title="属性 #3: Flex Shrink（收缩）"></a>属性 #3: Flex Shrink（收缩）</h3><p><code>flex-shrink</code> 正好和 <code>flex-grow</code> 相反，它是决定矩形子元素允许收缩多少的。</p><p>它的主要用途是指定哪些 flex 项 要缩小，哪些 flex 项 不要缩小。默认情况下，每个矩形子元素 (flex 项) 都为 <code>1</code> – 这意味着每个矩形子元素将随着容器收缩而收缩。</p><p>让我们看看实际情况。 在下面的 GIF 中，每个矩形子元素 (flex 项) 的 <code>flex-grow</code> 为<code>1</code>，所以他们填充满了整个容器，并且<code>flex-shrink</code> 为 <code>1</code>，所以他们被允许收缩。</p><p><img src="/images/pages/IMG10.gif" alt="image"></p><p>现在让我们将第 3 个矩形子元素的 <code>flex-shrink</code> 设置为 <code>0</code> 。它是禁止收缩，所以它会随着容器拉伸而拉伸，但是当容器收缩的时候，当其宽度收缩至设置的 120px 时，它不再允许收缩。</p><p><img src="/images/pages/IMG11.gif" alt="image"></p><p><code>flex-shrink</code> 的默认值是 <code>1</code> – 这意味着你的元素默认允许收缩，除非你告诉他们不允许收缩！</p><p>同样， <code>flex-shrink</code> 约为比例。如果一个矩形子元素的 <code>flex-shrink</code> 为 <code>6</code>，并且其余<code>flex-shrink</code> 为 <code>2</code>，那么这个矩形子元素随着容器空间的收缩，将以 3 倍于其他矩形子元素的速度缩小。</p><p>注意这里的措辞：3x（3 倍）<code>flex-shrink</code>的矩形子元素将缩小 3 倍。这并不是收缩 1/3 的宽度。</p><p>稍后，我们将深入了解元素是如何收缩和拉伸的。但首先，让我们了解最后一个属性，把这些东西都串起来。</p><h3 id="属性-4-Flex"><a href="#属性-4-Flex" class="headerlink" title="属性 #4: Flex"></a>属性 #4: Flex</h3><p><code>flex</code> 是 <code>flex-grow</code>，<code>flex-shrink</code> 和 <code>flex-basis</code> 的缩写 – 所有这些都放在一起。</p><p>它的默认值是<code>0</code>（grow），<code>1</code>（shrink）和 <code>auto</code>（basis）。</p><p>我们把上一个例子简化成只有两个矩形子元素 (flex 项)。</p><p>下面是它们的属性：</p><p>CSS 代码:</p><pre><code class="hljs css"><span class="hljs-selector-class">.square</span><span class="hljs-selector-id">#one</span> &#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">300px</span>;&#125;<span class="hljs-selector-class">.square</span><span class="hljs-selector-id">#two</span> &#123;  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">300px</span>;&#125;</code></pre><p>两个矩形子元素 (flex 项) 具有着相同的 <code>flex-basis</code>。这意味着如果它们有足够的空间（容器的空间是 600px 加上 <code>margin</code> 和 <code>padding</code> ），它们的宽度都是 300px 。</p><p>但随着容器的拉伸，第 1 个矩形子元素 (flex 项)（具有更高的 <code>flex-grow</code> ）将以两倍于第 2 个矩形子元素的速度增长。 随着容器的收缩，第 2 个矩形子元素（具有更高的柔性收缩）将会以两倍于第 1 个矩形子元素的的速度收缩。</p><p>实际效果如下图：</p><p><img src="/images/pages/IMG12.gif" alt="image"></p><h4 id="flex-项如何收缩和拉伸"><a href="#flex-项如何收缩和拉伸" class="headerlink" title="flex 项如何收缩和拉伸"></a>flex 项如何收缩和拉伸</h4><p>这里有什么可能会混淆：当第 1 个矩形子元素拉伸时，并没有拉伸到第 2 个矩形子元素的两倍大小。同样，当第 2 个矩形子元素缩小时，它不缩小到第 1 个矩形子元素的一半大小 – 即使<code>flex-shrink</code>(理解为收缩比率) 为<code>2</code>比<code>1</code>。</p><p>这两个属性并不是说它们的大小比例是 <code>2:1</code> 或者 <code>1:2</code>，而是说它们的收缩或拉伸速度的比率。</p><h4 id="简单的数学计算"><a href="#简单的数学计算" class="headerlink" title="简单的数学计算"></a>简单的数学计算</h4><p>容器的初始大小为 640px 。在容器的每一边占用 20px 的 <code>padding</code> ，剩下的空间足够让两个矩形子元素满足 <code>flex-basis</code> 等于 300px。</p><p>当容器设置为 430px 时，空间收缩了 210px 。(注：两个矩形子元素的 <code>flex-shrink</code> 加起来为 <code>3</code> ，那么， ) 第 1 个矩形子元素的 <code>flex-shrink</code> 为 <code>1</code>, 也就是收缩了 70px 。 第 2 个矩形子元素的 <code>flex-shrink</code> 为 <code>1</code> 也就是收缩了 140px 。</p><p>当容器收缩到 340px 时，空间收缩了 300px。第 1 个矩形子元素的收缩了 100px，第 2 个矩形子元素的收缩了 200px 。</p><p>容器收缩的空间根据它们各自的 <code>flex-shrink</code> 收缩率（2:1）的比率来分割。</p><p>这对于 <code>flex-grow</code> 也是同样的。 当容器拉伸到 940px 时，也就是说空间拉伸 300px ，第 1 个矩形子元素被拉伸 200px ，，第 2 个矩形子元素被拉伸 100px 。</p><p>当涉及到 flex 属性时，其实它们说的都是比例。</p><p><img src="/images/pages/IMG13.gif" alt="image"></p><p>在上面的 GIF 中，您可以看到宽度是如何根据比率进行调整的，增量（Δ）显示与 <code>flex-basis</code> 相比的差异。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>作为最后的总结：<code>flex-basis</code> 是控制元素在发生缩放之前，沿着主轴方向的大小。<code>flex-grow</code> 指的是在元素拉伸时，和兄弟元素之间相比的拉伸比例。而 <code>flex-shrink</code> 指的是在元素收缩时，和兄弟元素之间相比的收缩比例。</p><p>我们还有更多的 Flexbox 属性要介绍 – 在接下来的几周里请密切关注。</p><p>非常感谢阅读！ 如果你有一些特定的概念（ Flexbox 或其他），你想看到在类似的文章中解释，请留言。</p><p>原文地址：<a href="https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.9hknw1qpd">https://medium.freecodecamp.com/even-more-about-how-flexbox-works-explained-in-big-colorful-animated-gifs-a5a74812b053#.9hknw1qpd</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议</title>
    <link href="/2017/07/13/basic/HTTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2017/07/13/basic/HTTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="HTTP协议的主要特点"><a href="#HTTP协议的主要特点" class="headerlink" title="HTTP协议的主要特点"></a>HTTP协议的主要特点</h3><ol><li>支持客户/服务器模式。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。<br>由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<a id="more"></a></li></ol><h3 id="HTTP协议报文"><a href="#HTTP协议报文" class="headerlink" title="HTTP协议报文"></a>HTTP协议报文</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。比如 GET /data/info.html HTTP/1.1</p><p>方法字段就是HTTP使用的请求方法，比如常见的GET/POST</p><p>其中HTTP协议版本有两种：HTTP1.0/HTTP1.1 可以这样区别：</p><p>HTTP1.0对于每个连接都只能传送一个请求和响应，请求就会关闭，HTTP1.0没有Host字段;而HTTP1.1在同一个连接中可以传送多个请求和响应，多个请求可以重叠和同时进行，HTTP1.1必须有Host字段。</p><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p>HTTP客户程序(例如浏览器)，向服务器发送请求的时候必须指明请求类型(一般是GET或者 POST)。如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，但Content-Length除外。对于POST请求来说 Content-Length必须出现。</p><p>常见的请求头字段含义：</p><p>Accept： 浏览器可接受的MIME类型。</p><p>Accept-Charset：浏览器可接受的字符集。</p><p>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。</p><p>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。</p><p>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。</p><p>Content-Length：表示请求消息正文的长度。</p><p>Host： 客户机通过这个头告诉服务器，想访问的主机名。Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。</p><p>If-Modified-Since：客户机通过这个头告诉服务器，资源的缓存时间。只有当所请求的内容在指定的时间后又经过修改才返回它，否则返回304“Not Modified”应答。</p><p>Referer：客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的(防盗链)。包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</p><p>User-Agent：User-Agent头域的内容包含发出请求的用户信息。浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。</p><p>Cookie：客户机通过这个头可以向服务器带数据，这是最重要的请求头信息之一。</p><p>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。</p><p>From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。</p><p>Connection：处理完这次请求后是否断开连接还是继续保持连接。如果Servlet看到这里的值为“Keep- Alive”，或者看到请求使用的是HTTP 1.1(HTTP 1.1默认进行持久连接)，它就可以利用持久连接的优点，当页面包含多个元素时(例如Applet，图片)，显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入 ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。</p><p>Range：Range头域可以请求实体的一个或者多个子范围。例如，</p><p>表示头500个字节：bytes=0-499</p><p>表示第二个500字节：bytes=500-999</p><p>表示最后500个字节：bytes=-500</p><p>表示500字节以后的范围：bytes=500-</p><p>第一个和最后一个字节：bytes=0-0,-1</p><p>同时指定几个范围：bytes=500-600,601-999</p><p>但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206(PartialContent)返回而不是以200 (OK)。</p><p>UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p><h5 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h5><p>它的作用是通过一个空行，告诉服务器请求头部到此为止。</p><h5 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h5><p>若方法字段是GET，则此项为空，没有数据</p><p>若方法字段是POST,则通常来说此处放置的就是要提交的数据</p><p>比如要使用POST方法提交一个表单，其中有user字段中数据为“admin”, password字段为123456，那么这里的请求数据就是 user=admin&amp;password=123456，使用&amp;来连接各个字段。</p><p><img src="/images/pages/qingqiuti.png" alt="image"></p><p><img src="/images/pages/qingqiudemo.jpg" alt="image"></p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><h5 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h5><p>响应行一般由协议版本、状态码及其描述组成 比如 HTTP/1.1 200 OK</p><p>其中协议版本HTTP/1.1或者HTTP/1.0，200就是它的状态码，OK则为它的描述。</p><p>//常见状态码：</p><p>100~199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。</p><p>200~299：表示成功接收请求并已完成整个处理过程。常用200</p><p>300~399：为完成请求，客户需进一步细化请求。例如：请求的资源已经移动一个新地址、常用302(意味着你请求我，我让你去找别人),307和304(我不给你这个资源，自己拿缓存)</p><p>400~499：客户端的请求有错误，常用404(意味着你请求的资源在web服务器中没有)403(服务器拒绝访问，权限不够)</p><p>500~599：服务器端出现错误，常用500</p><p><a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin">更加详细的状态码</a></p><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p>响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。</p><p>设置HTTP响应头往往和状态码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401(Unauthorized)状态代码则必须伴随一个WWW-Authenticate头。然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，……等等许多其他任务。</p><p>常见的响应头字段含义：</p><p>Allow：服务器支持哪些请求方法(如GET、POST等)。</p><p>Content-Encoding：文档的编码(Encode)方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE4、IE5才支持它。因此，Servlet应该通过查看Accept-Encoding头(即request.getHeader(“Accept- Encoding”))检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</p><p>Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</p><p>Content- Type：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置 Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</p><p>Date：当前的GMT时间，例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</p><p>Expires：告诉浏览器把回送的资源缓存多长时间，-1或0则是不缓存。</p><p>Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态。Last-Modified也可用setDateHeader方法来设置。</p><p>Location：这个头配合302状态码使用，用于重定向接收者到一个新URI地址。表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</p><p>Refresh：告诉浏览器隔多久刷新一次，以秒计。</p><p>Server：服务器通过这个头告诉浏览器服务器的类型。Server响应头包含处理请求的原始服务器的软件信息。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。Servlet一般不设置这个值，而是由Web服务器自己设置。</p><p>Set-Cookie：设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。</p><p>Transfer-Encoding：告诉浏览器数据的传送格式。</p><p>WWW-Authenticate：客户应该在Authorization头中提供什么类型的授权信息?在包含401(Unauthorized)状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=\”executives\”“)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问。</p><p>注：设置应答头最常用的方法是HttpServletResponse的setHeader，该方法有两个参数，分别表示应答头的名字和值。和设置状态代码相似，设置应答头应该在发送任何文档内容之前进行。</p><p>setDateHeader方法和setIntHeadr方法专门用来设置包含日期和整数值的应答头，前者避免了把Java时间转换为GMT时间字符串的麻烦，后者则避免了把整数转换为字符串的麻烦。</p><p>HttpServletResponse还提供了许多设置</p><p>setContentType：设置Content-Type头。大多数Servlet都要用到这个方法。</p><p>setContentLength：设置Content-Length头。对于支持持久HTTP连接的浏览器来说，这个函数是很有用的。</p><p>addCookie：设置一个Cookie(Servlet API中没有setCookie方法，因为应答往往包含多个Set-Cookie头)。</p><h5 id="空行-1"><a href="#空行-1" class="headerlink" title="空行"></a>空行</h5><p>它的作用是通过一个空行，告诉服务器请求头部到此为止。</p><h5 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h5><p>响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。</p><p><img src="/images/pages/xiangying.jpg" alt="image"></p><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><ol><li>GET：获取资源</li><li>POST：传输资源</li><li>PUT：更新资源</li><li>DELETE：删除资源</li><li>HEAD：获取报文首部</li></ol><h3 id="POST请求和GET请求的区别"><a href="#POST请求和GET请求的区别" class="headerlink" title="POST请求和GET请求的区别"></a>POST请求和GET请求的区别</h3><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被收藏，而POST不可以。</li><li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><h4 id="HTTP持久连接"><a href="#HTTP持久连接" class="headerlink" title="HTTP持久连接"></a>HTTP持久连接</h4><p>HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成后立即断开连接（HTTP协议为无连接的协议。</p><p>当使用Keep-Alive模式（又称持久连接，连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p><p><strong>只有http1.1开始支持持久连接</strong></p><h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>在使用持久连接的情况下，某个连接上的消息传递是这样的：<br>请求1-&gt;响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3</p><p>管线化，则消息的传递变成这样：<br>请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3</p><h4 id="管线化的特点"><a href="#管线化的特点" class="headerlink" title="管线化的特点"></a>管线化的特点</h4><ol><li><p>管线化机制通过持久连接完成，仅HTTP/1.1 支持此技术</p></li><li><p>只有GET和HEAD请求可以进行管线化，而POST则有所限制  </p></li><li><p>初次创建连接时不应启动管线机制，因为对方(服务器)不一定支持HTTP/1.1版本的协议  </p></li><li><p>管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变</p></li><li><p>HTTP /1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可  </p></li><li><p>由于.上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如<strong>Chrome和Firefox</strong> 默认并未开启管线化支持</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack相关问题</title>
    <link href="/2017/06/25/webapck/webpack%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2017/06/25/webapck/webpack%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>随着现代前端开发的复杂度和规模越来越庞大，已经不能抛开工程化来独立开发了，如 react 的 jsx 代码必须编译后才能在浏览器中使用；又如 sass 和 less 的代码浏览器也是不支持的。 而如果摒弃了这些开发框架，那么开发的效率将大幅下降。在众多前端工程化工具中，webpack 脱颖而出成为了当今最流行的前端构建工具。 然而大多数的使用者都只是单纯的会使用，而并不知道其深层的原理。希望通过以下的面试题总结可以帮助大家温故知新、查缺补漏，知其然而又知其所以然。</p><a id="more"></a><h2 id="问题一览"><a href="#问题一览" class="headerlink" title="问题一览"></a>问题一览</h2><ol><li>webpack 与 grunt、gulp 的不同？</li><li>与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？</li><li>有哪些常见的 Loader？他们是解决什么问题的？</li><li>有哪些常见的 Plugin？他们是解决什么问题的？</li><li>Loader 和 Plugin 的不同？</li><li>webpack 的构建流程是什么? 从读取配置到输出文件这个过程尽量说全</li><li>是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？</li><li>webpack 的热更新是如何做到的？说明其原理？</li><li>如何利用 webpack 来优化前端性能？（提高性能和体验）</li><li>如何提高 webpack 的构建速度？</li><li>怎么配置单页应用？怎么配置多页应用？</li><li>npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？</li><li>如何在 vue 项目中实现按需加载？</li></ol><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><h3 id="1-webpack-与-grunt、gulp-的不同？"><a href="#1-webpack-与-grunt、gulp-的不同？" class="headerlink" title="1. webpack 与 grunt、gulp 的不同？"></a>1. webpack 与 grunt、gulp 的不同？</h3><p>三者都是前端构建工具，grunt 和 gulp 在早期比较流行，现在 webpack 相对来说比较主流，不过一些轻量化的任务还是会用 gulp 来处理，比如单独打包 CSS 文件等。</p><p>grunt 和 gulp 是基于任务和流（Task、Stream）的。类似 jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个 web 的构建流程。</p><p>webpack 是基于入口的。webpack 会自动地递归解析入口所需要加载的所有资源文件，然后用不同的 Loader 来处理不同的文件，用 Plugin 来扩展 webpack 功能。</p><p>所以总结一下：</p><ul><li>从构建思路来说</li></ul><p>gulp 和 grunt 需要开发者将整个前端构建过程拆分成多个 <code>Task</code>，并合理控制所有 <code>Task</code> 的调用关系 webpack 需要开发者找到入口，并需要清楚对于不同的资源应该使用什么 Loader 做何种解析和加工</p><ul><li>对于知识背景来说</li></ul><p>gulp 更像后端开发者的思路，需要对于整个流程了如指掌 webpack 更倾向于前端开发者的思路</p><h3 id="2-与-webpack-类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用-webpack？"><a href="#2-与-webpack-类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用-webpack？" class="headerlink" title="2. 与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？"></a>2. 与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？</h3><p>同样是基于入口的打包工具还有以下几个主流的：</p><ul><li>webpack</li><li>rollup</li><li>parcel</li></ul><p><strong>从应用场景上来看：</strong></p><ul><li>webpack 适用于大型复杂的前端站点构建</li><li>rollup 适用于基础库的打包，如 vue、react</li><li>parcel 适用于简单的实验性项目，他可以满足低门槛的快速看到效果</li></ul><p>由于 parcel 在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用 parcel</p><h3 id="3-有哪些常见的-Loader？他们是解决什么问题的？"><a href="#3-有哪些常见的-Loader？他们是解决什么问题的？" class="headerlink" title="3. 有哪些常见的 Loader？他们是解决什么问题的？"></a>3. 有哪些常见的 Loader？他们是解决什么问题的？</h3><ul><li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li><li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li><li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li><li>image-loader：加载并且压缩图片文件</li><li>babel-loader：把 ES6 转换成 ES5</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul><h3 id="4-有哪些常见的-Plugin？他们是解决什么问题的？"><a href="#4-有哪些常见的-Plugin？他们是解决什么问题的？" class="headerlink" title="4. 有哪些常见的 Plugin？他们是解决什么问题的？"></a>4. 有哪些常见的 Plugin？他们是解决什么问题的？</h3><ul><li>define-plugin：定义环境变量</li><li>commons-chunk-plugin：提取公共代码</li><li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码</li></ul><h3 id="5-Loader-和-Plugin-的不同？"><a href="#5-Loader-和-Plugin-的不同？" class="headerlink" title="5.Loader 和 Plugin 的不同？"></a>5.Loader 和 Plugin 的不同？</h3><p><strong>不同的作用</strong></p><ul><li><strong>Loader</strong> 直译为 “加载器”。Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。</li><li><strong>Plugin</strong> 直译为 “插件”。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><p><strong>不同的用法</strong></p><ul><li><strong>Loader</strong> 在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载 (loader) 和使用的参数（options）</li><li><strong>Plugin</strong> 在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。</li></ul><h3 id="6-webpack-的构建流程是什么-从读取配置到输出文件这个过程尽量说全"><a href="#6-webpack-的构建流程是什么-从读取配置到输出文件这个过程尽量说全" class="headerlink" title="6.webpack 的构建流程是什么? 从读取配置到输出文件这个过程尽量说全"></a>6.webpack 的构建流程是什么? 从读取配置到输出文件这个过程尽量说全</h3><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li><li>确定入口：根据配置中的 entry 找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h3 id="7-是否写过-Loader-和-Plugin？描述一下编写-loader-或-plugin-的思路？"><a href="#7-是否写过-Loader-和-Plugin？描述一下编写-loader-或-plugin-的思路？" class="headerlink" title="7. 是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？"></a>7. 是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？</h3><p>Loader 像一个 “翻译官” 把读到的源文件内容转义成新的文件内容，并且每个 Loader 通过链式操作，将源文件一步步翻译成想要的样子。</p><p>编写 Loader 时要遵循单一原则，每个 Loader 只做一种 “转义” 工作。 每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback() 方法，将内容返回给 webpack。 还可以通过 this.async() 生成一个 callback 函数，再用这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发 loader 的工具函数集——loader-utils。</p><p>相对于 Loader 而言，Plugin 的编写就灵活了许多。 webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><h3 id="8-webpack-的热更新是如何做到的？说明其原理？"><a href="#8-webpack-的热更新是如何做到的？说明其原理？" class="headerlink" title="8.webpack 的热更新是如何做到的？说明其原理？"></a>8.webpack 的热更新是如何做到的？说明其原理？</h3><p>webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>原理：</p><p><img src="/images/pages/webpack1.jpeg" alt="image"></p><p>首先要知道 server 端和 client 端都做了处理工作</p><ol><li>第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</li><li>第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API 对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</li><li>第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</li><li>第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</li><li>webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</li><li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</li><li>而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</li><li>最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</li></ol><h3 id="9-如何利用-webpack-来优化前端性能？（提高性能和体验）"><a href="#9-如何利用-webpack-来优化前端性能？（提高性能和体验）" class="headerlink" title="9. 如何利用 webpack 来优化前端性能？（提高性能和体验）"></a>9. 如何利用 webpack 来优化前端性能？（提高性能和体验）</h3><p>用 webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运行快速高效。</p><ul><li>压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用 webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS 文件， 利用 cssnano（css-loader?minimize）来压缩 css</li><li>利用 <a href="https://cloud.tencent.com/product/cdn?from=10680">CDN</a> 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径。可以利用 webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径</li><li>删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动 webpack 时追加参数 –optimize-minimize 来实现</li><li>提取公共代码。</li></ul><h3 id="10-如何提高-webpack-的构建速度？"><a href="#10-如何提高-webpack-的构建速度？" class="headerlink" title="10. 如何提高 webpack 的构建速度？"></a>10. 如何提高 webpack 的构建速度？</h3><ol><li>多入口情况下，使用 CommonsChunkPlugin 来提取公共代码</li><li>通过 externals 配置来提取常用库</li><li>利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。</li><li>使用 Happypack 实现多线程加速编译</li><li>使用 webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度</li><li>使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码</li></ol><h3 id="11-怎么配置单页应用？怎么配置多页应用？"><a href="#11-怎么配置单页应用？怎么配置多页应用？" class="headerlink" title="11. 怎么配置单页应用？怎么配置多页应用？"></a>11. 怎么配置单页应用？怎么配置多页应用？</h3><p>单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可，这里不再赘述</p><p>多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是：</p><ul><li>每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套 css 样式表</li><li>随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置</li></ul><h3 id="12-npm-打包时需要注意哪些？如何利用-webpack-来更好的构建？"><a href="#12-npm-打包时需要注意哪些？如何利用-webpack-来更好的构建？" class="headerlink" title="12.npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？"></a>12.npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？</h3><p>Npm 是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是 JS 模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于 NPM 模块上传的方法可以去官网上进行学习，这里只讲解如何利用 webpack 来构建。</p><p>NPM 模块需要注意以下问题：</p><ol><li>要支持 CommonJS 模块化规范，所以要求打包后的最后结果也遵守该规则。</li><li>Npm 模块使用者的环境是不确定的，很有可能并不支持 ES6，所以打包的最后结果应该是采用 ES5 编写的。并且如果 ES5 是经过转换的，请最好连同 SourceMap 一同上传。</li><li>Npm 包大小应该是尽量小（有些仓库会限制包大小）</li><li>发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。</li><li>UI 组件类的模块应该将依赖的其它资源文件，例如. css 文件也需要包含在发布的模块里。</li></ol><p>基于以上需要注意的问题，我们可以对于 webpack 配置做以下扩展和优化：</p><ol><li>CommonJS 模块化规范的解决方案： 设置 output.libraryTarget=’commonjs2’使输出的代码符合 CommonJS2 模块化规范，以供给其它模块导入使用</li><li>输出 ES5 代码的解决方案：使用 babel-loader 把 ES6 代码转换成 ES5 的代码。再通过开启 devtool: ‘source-map’输出 SourceMap 以发布调试。</li><li>Npm 包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改. babelrc 文件，为其加入 transform-runtime 插件</li><li>不能将依赖模块打包到 NPM 模块中的解决方案：使用 externals 配置项来告诉 webpack 哪些模块不需要打包。</li><li>对于依赖的资源文件打包的解决方案：通过 css-loader 和 extract-text-webpack-plugin 来实现，配置如下：</li></ol><p><img src="/images/pages/webpack2.jpeg" alt="image"></p><h3 id="13-如何在-vue-项目中实现按需加载？"><a href="#13-如何在-vue-项目中实现按需加载？" class="headerlink" title="13. 如何在 vue 项目中实现按需加载？"></a>13. 如何在 vue 项目中实现按需加载？</h3><p>Vue UI 组件库的按需加载 为了快速开发前端项目，经常会引入现成的 UI 组件库如 ElementUI、iView 等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。</p><p>不过很多组件库已经提供了现成的解决方案，如 Element 出品的 babel-plugin-component 和 AntDesign 出品的 babel-plugin-import 安装以上插件后，在. babelrc 配置中或 babel-loader 的参数中进行设置，即可实现组件按需加载了。</p><p><img src="/images/pages/webpack3.png" alt="image"></p><p>单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。</p><p>通过 import(<em>) 语句来控制加载时机，webpack 内置了对于 import(</em>) 的解析，会将 import(<em>) 中引入的模块作为一个新的入口在生成一个 chunk。 当代码执行到 import(</em>) 语句时，会去加载 Chunk 对应生成的文件。import() 会返回一个 Promise 对象，所以为了让浏览器支持，需要事先注入 Promise polyfill</p><p><strong>参考文章</strong></p><ul><li>关于 webpack 的面试题有哪些？</li><li>前端面试之 webpack 面试常见问题</li><li>《深入浅出 webpack》电子版</li><li>webpack 构建性能优化策略小结</li></ul>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型链</title>
    <link href="/2017/06/24/basic/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2017/06/24/basic/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="原型链的介绍"><a href="#原型链的介绍" class="headerlink" title="原型链的介绍"></a>原型链的介绍</h2><h3 id="什么是原型？"><a href="#什么是原型？" class="headerlink" title="什么是原型？"></a>什么是原型？</h3><p>js中，任何对象都有一个原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的prototype指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有prototype，只有方法才有prototype。</p><h3 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h3><p>  原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有_proto_指向了。</p><a id="more"></a><h2 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h2><ol><li>字面量<pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;demo&#x27;</span> &#125;;</code></pre></li><li>字面量（使用了Object的构造方法）<pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;demo&#x27;</span> &#125;);</code></pre></li><li>构造函数<pre><code class="hljs js"><span class="hljs-keyword">var</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;demo&#x27;</span>;&#125;<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> func();</code></pre></li><li>Object.create<pre><code class="hljs js"><span class="hljs-keyword">var</span> demo = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;demo&#x27;</span> &#125;;<span class="hljs-keyword">var</span> d = <span class="hljs-built_in">Object</span>.create(demo);</code></pre></li></ol><h3 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h3><p><strong>首先，当我们声明一个function关键字的方法时，会为这个方法添加一个prototype属性，指向默认的原型对象，并且此prototype的constructor属性也指向方法对象。此二个属性会在创建对象时被对象的属性引用。</strong></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hello</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-built_in">console</span>.log(Hello.prototype); <span class="hljs-comment">// Object &#123;&#125; -- &gt; 内部的constructor 指向Hello方法</span><span class="hljs-built_in">console</span>.log(Hello.prototype.constructor); <span class="hljs-comment">// function Hello()&#123;&#125;</span></code></pre><p><strong>我们如果用Hello创建一个对象h，看这个对象有什么属性。</strong></p><pre><code class="hljs js">   <span class="hljs-built_in">console</span>.log(h.constructor); <span class="hljs-comment">// function Hello()&#123;&#125;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(h)==Hello.prototype); <span class="hljs-comment">// true  备注：getPrototypeOf是获取_proto_</span></code></pre><p> 我们惊喜的发现，new出来的对象，它的constructor指向了方法对象，它的_proto_和prototype相等。</p><p>  即new一个对象，它的_proto_属性指向了方法的prototype属性，并且constructor指向了prototype的constructor属性。</p><h3 id="创建对象的过程-1"><a href="#创建对象的过程-1" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h3><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hehe</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;&#125;<span class="hljs-keyword">var</span> h = <span class="hljs-keyword">new</span> Hehe(<span class="hljs-string">&quot;笑你妹&quot;</span>);<span class="hljs-comment">//伪代码:</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newObj</span>(<span class="hljs-params">name</span>)</span>&#123; <span class="hljs-keyword">var</span> obj = &#123;&#125;; obj.__proto__ = Hehe.prototype;  obj.constructor = Hehe.prototype.constructor; <span class="hljs-keyword">var</span> result = Hehe.call(obj, name); <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result===<span class="hljs-string">&#x27;object&#x27;</span>&amp;&amp; result!=<span class="hljs-literal">null</span> ? result : obj;  <span class="hljs-comment">//当无返回对象或默认时返回obj。</span>&#125;<span class="hljs-keyword">var</span> hh = newObj(<span class="hljs-string">&quot;笑你妹&quot;</span>);<span class="hljs-built_in">console</span>.log(hh);<span class="hljs-built_in">console</span>.log(h);<span class="hljs-comment">//虽然hh!=h,但是可以看到这个hh就和h的结构一样了。</span></code></pre><p><strong>过程：先创建一个空对象，设置一个_proto_指向方法的原型，设置constructor，用新对象做this指向方法，返回新对象。</strong></p><h2 id="原型以及原型链关系"><a href="#原型以及原型链关系" class="headerlink" title="原型以及原型链关系"></a>原型以及原型链关系</h2><p><img src="/images/pages/yuanxing.png" alt="image"></p><p><img src="/images/pages/gouzao.png" alt="image"></p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote><p>任何对象都有一个原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的prototype指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有prototype，只有方法才有prototype。</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person();<span class="hljs-comment">//方法才有prototype,普通对象无prototype</span><span class="hljs-built_in">console</span>.log(Person.prototype); <span class="hljs-comment">// Object&#123;&#125; </span><span class="hljs-built_in">console</span>.log(p.prototype); <span class="hljs-comment">// undifined</span><span class="hljs-comment">//任何对象都是有构造函数的,Person这种方法的构造函数是Function。</span><span class="hljs-comment">//备注:constructor很容易被改变，一般不用它，此处只是打印下列对象的构造函数是什么。</span><span class="hljs-built_in">console</span>.log(p.constructor); <span class="hljs-comment">//function Person()&#123;&#125;  </span><span class="hljs-built_in">console</span>.log(Person.constructor); <span class="hljs-comment">//function Function()&#123;&#125; </span><span class="hljs-built_in">console</span>.log(&#123;&#125;.constructor); <span class="hljs-comment">// function Object()&#123;&#125;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.constructor); <span class="hljs-comment">// function Function() &#123;&#125;</span><span class="hljs-built_in">console</span>.log([].constructor);  <span class="hljs-comment">//function Array()&#123;&#125;</span></code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p> 用function声明的都是函数，而如果直接调用的话，那么Person()就是一个普通函数，只有用函数new产生对象时，这个函数才是new出来对象的构造函数。</p></blockquote><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><blockquote><p>原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到Object时，就没有_proto_指向了。</p></blockquote><p>属性搜索原则：</p><ol><li>当访问一个对象的成员的时候，会现在自身找有没有,如果找到直接使用。</li><li>如果没有找到，则去原型链指向的对象的构造函数的prototype中找，找到直接使用，没找到就返回undifined或报错。<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>)</span>&#123;           <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person();    <span class="hljs-comment">//p ---&gt; Person.prototype ---&gt;Object.prototype----&gt;null</span></code></pre><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3></li></ol><pre><code class="hljs js"><span class="hljs-comment">//原型继承的基本案例</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;<span class="hljs-built_in">this</span>.age = age;&#125;<span class="hljs-comment">//1.直接替换原型对象 </span><span class="hljs-keyword">var</span> parent = &#123;sayHello : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;方式1：替换原型对象&quot;</span>);&#125;&#125;Person.prototype = parent;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">50</span>);p.sayHello();<span class="hljs-comment">//2.混入式原型继承</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;.............混入式原型继承..............&quot;</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, age</span>) </span>&#123;<span class="hljs-built_in">this</span>.name = name;<span class="hljs-built_in">this</span>.age = age;&#125;<span class="hljs-keyword">var</span> parent2 = &#123;sayHello : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;方式2：原型继承之混入式加载成员&quot;</span>);&#125;&#125;<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> parent2) &#123;Student.prototype[k] = parent2[k];&#125;<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">50</span>);p.sayHello();</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><strong>instanceof运算符用来判断一个构造函数的prototype属性所指向的对象是否存在另外一个要检测对象的原型链上</strong></p><pre><code class="hljs js">c; <span class="hljs-comment">// function &#123;name: &quot;demo&quot;&#125;</span>c <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true</span></code></pre><p>为什么会是true呢？？</p><pre><code class="hljs js">   c; <span class="hljs-comment">// function &#123;name: &quot;demo&quot;&#125;</span>c <span class="hljs-keyword">instanceof</span> func; <span class="hljs-comment">// true</span>c.__proto__ === func.prototype; <span class="hljs-comment">// true</span>func.prototype.__proto__ === <span class="hljs-built_in">Object</span>.prototype; <span class="hljs-comment">// true</span>c <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>; <span class="hljs-comment">// true</span></code></pre><p><strong>所以，instanceof不能用来判断对象的类型！！！</strong>  </p><p>那么我们用什么来判断对象的类型呢？</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><pre><code class="hljs js">   c.__proto__.constructor===func <span class="hljs-comment">// true</span>c.__proto__.constructor===<span class="hljs-built_in">Object</span> <span class="hljs-comment">// false</span></code></pre><h2 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h2><p>当我们用new运算符new一个构造函数产生一个实例时，比如说： var obj = new Func 时，其背后的步骤是这样的：</p><ol><li>创建一个继承自 Func.prototype 的新对象；</li><li>执行构造函数 Func ，执行的时候，相应的传参会被传入，同时上下文(this)会被指定为第一步创建的新实例；</li><li>如果构造函数返回了一个“对象”,那么这个对象会取代步骤1中new出来的实例被返回。如果构造函数没有返回对象,那么new出来的结果为步骤1创建的对象。</li></ol><p><strong>注意：new Func 等同于new Func()，只能用在不传递任何参数的情况。</strong></p><h3 id="new的模拟实现"><a href="#new的模拟实现" class="headerlink" title="new的模拟实现"></a>new的模拟实现</h3><pre><code class="hljs js"><span class="hljs-comment">//new运算符原理实现</span><span class="hljs-keyword">var</span> new1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fun</span>)</span>&#123;    <span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">Object</span>.create(fun.prototype);    <span class="hljs-keyword">var</span> returnObj = fun.call(newObj);    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> returnObj === <span class="hljs-string">&#x27;object&#x27;</span>)&#123;        <span class="hljs-keyword">return</span> returnObj    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> newObj    &#125;&#125;</code></pre><p>其中  var newObj  = Object.create(fun.prototype)  的意思是：创建一个新对象newObj，并让<code>newObj.__proto__ </code>指向 fun，即  <code>newObj.__proto__=== fun </code>返回true。<br><strong>方法的使用</strong></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> strObj = new1(<span class="hljs-built_in">String</span>);alert(strObj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>); <span class="hljs-comment">//true</span>alert(strObj.__proto__.constructor === <span class="hljs-built_in">String</span>); <span class="hljs-comment">//true</span></code></pre><p><strong>可以看到，new1函数的运行效果和new运算符是一样的。我们继续给String的原型上添加一个方法，看看new1函数得到的strObj能否继承到这个方法：</strong></p><pre><code class="hljs js"><span class="hljs-built_in">String</span>.prototype.defineByN = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    alert(<span class="hljs-string">&quot;我是自定义方法&quot;</span>);&#125;strObj.defineByN();  <span class="hljs-comment">//弹出“我是自定义方法”</span></code></pre><p>可以看到new1函数得到的strObj继承了到这个方法。</p><h2 id="问题：为什么Object-create创建的对象和其他几种不一样呢？"><a href="#问题：为什么Object-create创建的对象和其他几种不一样呢？" class="headerlink" title="问题：为什么Object.create创建的对象和其他几种不一样呢？"></a>问题：为什么Object.create创建的对象和其他几种不一样呢？</h2><p>因为使用原型链进行的创造对象。</p><pre><code class="hljs ini"><span class="hljs-attr">d.__proto__</span>===demo<span class="hljs-comment">; // true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM事件流</title>
    <link href="/2017/06/12/basic/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <url>/2017/06/12/basic/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是事件？"><a href="#什么是事件？" class="headerlink" title="什么是事件？"></a>什么是事件？</h2><blockquote><p>事件, 就是文档或浏览器窗口发生的一些特定的交互瞬间. JavaScript 和 HTML 之间的交互是通过事件实现的. 可以使用事件监听器来监听事件, 以便事件发生时执行相应的代码.</p></blockquote><a id="more"></a><h2 id="事件流是什么？"><a href="#事件流是什么？" class="headerlink" title="事件流是什么？"></a>事件流是什么？</h2><p>当在页面上某个元素触发特定事件时, 比如点击, 除了被点击的目标元素, 所有祖先元素都会触发该事件, 一直到 window.</p><p>那这样就出现了一个问题, 是先在目标元素上触发事件, 还是先在祖先元素上触发呢? 这就是事件流的概念.</p><p><strong>事件流是事件在目标元素和祖先元素间的触发顺序</strong></p><ul><li><strong>捕获</strong>- Capture - 事件由最顶层逐级向下传播, 直至到达目标元素.</li><li><strong>冒泡</strong> - Bubble - 顾名思义, 类似水中冒泡, 从下往上. 事件由第一个被触发的元素接收, 然后逐级向上传播.</li></ul><p>后来 w3c 采用折中的方式, 规定先捕获再冒泡平息了战火. 如此一个事件就被分成了三个阶段(是的, 不光是捕获和冒泡):</p><ol><li>捕获阶段 - The capture phase - 事件从最顶层元素 window 一直传递到目标元素的父元素.</li><li>目标阶段 - The target phase - 事件到达目标元素. 如果事件指定不冒泡. 那就会在这里中止.</li><li>冒泡阶段 - The bubble phase - 事件从目标元素父元素向上逐级传递直到最顶层元素 window. 及捕获阶段的反方向.</li></ol><p>那这里又有一个新的疑问, 既然捕获和冒泡阶段都会触发事件, 那先捕获再冒泡, 岂不是路径上的元素都会触发两次事件?</p><p>在 DOM2 中, 事件监听机制提供了一个参数来决定事件是在捕获阶段生效还是在冒泡阶段生效, 接下来简要学习下 ==addEventListener== .</p><h2 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h2><p><strong>EventTarget.addEventListener()</strong> 方法将指定的监听器注册到目标元素上, 当该对象触发指定的事件时, 指定的回调函数就会被执行. 事件目标可以是一个文档上的元素或任何其他支持事件的对象 (比如 XMLHttpRequest).</p><p>它的工作原理是将实现EventListener的函数或对象添加到调用它的 EventTarget 上的指定事件类型的事件侦听器列表中.</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code class="hljs reasonml">target.add<span class="hljs-constructor">EventListener(<span class="hljs-params">type</span>, <span class="hljs-params">listener</span>[, <span class="hljs-params">options</span>])</span>;target.add<span class="hljs-constructor">EventListener(<span class="hljs-params">type</span>, <span class="hljs-params">listener</span>[, <span class="hljs-params">useCapture</span>])</span>;target.add<span class="hljs-constructor">EventListener(<span class="hljs-params">type</span>, <span class="hljs-params">listener</span>[, <span class="hljs-params">useCapture</span>, <span class="hljs-params">wantsUntrusted</span>  ])</span>;  <span class="hljs-comment">// Gecko/Mozilla only</span></code></pre><ul><li>type: 表示监听事件类型的字符串. 事件列表.</li><li>listener: 当所监听的事件类型触发时的回调. 会接收到一个事件通知对象.</li><li>options: 可选. 可用的选项如下:</li><li>capture: Boolean, 如果是 true, 表示 listener 会在捕获阶段触发. 默认是 false. 冒泡捕获. 所以微软牛逼.</li><li>once: Boolean, 如果是 true, 表示 listener 在添加之后最多只调用一次.</li><li>passive: Boolean，如果是, 表示 listener 永远不会调用 preventDefault(). 如果 listener 仍然调用了这个函数, 客户端将会忽略它并抛出一个控制台警告.</li><li>useCapture: 可选. Boolean, 同 options - capture</li></ul><blockquote><p>注意: 对于目标元素上的事件监听器来说, 事件会处于目标阶段, 而不是冒泡阶段或者捕获阶段. 在目标阶段的事件会触发该元素上的所有监听器, 而不在乎这个监听器到底在注册时 useCapture 是 true 还是 false.</p></blockquote><h2 id="事件监听添加与移除"><a href="#事件监听添加与移除" class="headerlink" title="事件监听添加与移除"></a>事件监听添加与移除</h2><h3 id="事件添加的三种方式"><a href="#事件添加的三种方式" class="headerlink" title="事件添加的三种方式"></a>事件添加的三种方式</h3><ol><li><p>通过HTML 属性的方式</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;click&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></li><li><p>DOM0 中可以通过js脚本来给指定元素提供事件处理函数，即</p><pre><code class="hljs awk">element.onclick = <span class="hljs-keyword">function</span> <span class="hljs-regexp">//</span> 只会在冒泡阶段生效</code></pre></li><li><p>DOM2 中, 添加了新的事件监听API, 即<code>addEventListener</code>, 同时提供了取消监听的 <code>removeEventListener(type, handler[, options | useCapture])</code>. 显然事件处理函数注册后, 要取消监听, <code>type/hanlder/useCapture</code>的一致.</p></li></ol><p>相比第一, 第二种, <code>addEventListener</code>的方式有以下几点优势:</p><ul><li>可以为同一个事件注册多个回调函数, 依次触发. 而 DOM0 的方式则会被覆盖掉. 只能添加一种</li><li>使用 DOM0 会覆盖 HTML 的方式.</li><li>可以通过参数决定监听是在冒泡阶段生效还是在捕获阶段生效.</li><li><code>element.onclick</code> 注册的监听只会在冒泡阶段生效</li></ul><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;html&#x27;)&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;child&#x27;</span>) child.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;DOM0A&#x27;</span>) &#125; <span class="hljs-comment">// 覆盖了 HTML 的方式</span>child.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;DOM0B&#x27;</span>) &#125; <span class="hljs-comment">// 覆盖了上一条 DOM0A   </span>child.addEventLisnter(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;lisnterA&#x27;</span>) &#125;)child.addEventLisnter(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;lisnterB&#x27;</span>) &#125;) <span class="hljs-comment">// 不会覆盖</span></code></pre><h5 id="三种方式对应的如何移除"><a href="#三种方式对应的如何移除" class="headerlink" title="三种方式对应的如何移除:"></a>三种方式对应的如何移除:</h5><pre><code class="hljs js">child.setAttributer(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-literal">false</span>)child.onclick = <span class="hljs-literal">null</span>child.removeEventLisnter(<span class="hljs-string">&#x27;设置相同的参数&#x27;</span>)</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>以下代码的输出顺序</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;html&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">        <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            <span class="hljs-keyword">const</span> parent = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;parent&quot;</span>);</span><span class="javascript">            <span class="hljs-keyword">const</span> child = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;child&quot;</span>);</span><span class="javascript">            child.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child onclick&#x27;</span>) &#125;;</span><span class="javascript">            <span class="hljs-comment">// capture 默认为 false, 冒泡</span></span><span class="javascript">            parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent event&#x27;</span>) &#125;);</span><span class="javascript">            child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child event&#x27;</span>) &#125;);</span><span class="javascript">            <span class="hljs-comment">// 捕获</span></span><span class="javascript">            parent.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent event capture&#x27;</span>) &#125;, &#123; <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> &#125;);</span><span class="javascript">            child.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child event capture&#x27;</span>) &#125;, &#123; <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span> &#125;);</span>        &#125;<span class="javascript">        <span class="hljs-built_in">window</span>.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;window&#x27;</span>);</span>        &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;body&#x27;)&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;parent html&#x27;)&quot;</span>&gt;</span>parent        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;child&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;child html&#x27;)&quot;</span>&gt;</span>child<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></li><li><p>什么是事件流，同一个事件有几个阶段？</p></li><li><p>如何移除通过HTML属性、element.onclick等注册的事件处理函数？</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3></li></ol><p>首先参考 chrome 浏览器的结果. 先来看点击 child, 输出:  </p><ol><li>parent html</li><li>parent event</li><li>parent event capture</li><li>body</li><li>html</li><li>window</li></ol><p>奇怪! 这时候不是应该先捕获, capture 在前吗? 别急, 这时候如果调换 parent event 与 parent event capture 的 addEventListener 顺序, 会发现, 输出顺序也变了:</p><ol><li>parent html</li><li><strong>parent event capture</strong></li><li><strong>parent event</strong></li><li>body</li><li>html</li><li>window</li></ol><p>其实这时候的输出顺序只和 <code>addEventListener</code> 的顺序有关. 是否开启 <code>capture</code> 无关. 因为我们是直接点击了 <code>parent</code>. 对于 <code>parent</code> 自身而言. 它在整个点击传递过程中处于目标阶段. 并不涉及捕获和冒泡. 同时我们也发现. html 设置的点击是优先于 <code>addEventListener</code> 的方式的.</p><p>我们再来看下点击 child:</p><ol><li>parent event capture</li><li>hild onclick</li><li>child event</li><li>child event capture</li><li>parent html</li><li>parent event</li><li>body</li><li>html</li><li>window</li></ol><p>首先, child html 没有输出, 因为被 child onclick 覆盖掉了.</p><p>第二点, child onclick 的优先级也是高于 <code>addEventListener</code> 的.</p><p>再然后, 点击事件传递过程中, 首先在捕获阶段, 输出了 parent event capture. 然后到达目标阶段. 同理之前点击 parent. 如果此时调换 child event 与 child event capture 的 <code>addEventListener</code> 顺序. 输出顺序也会改变</p><p>最后, 到达冒泡阶段, 由于 html 的优先级高于 <code>addEventListener</code>. 所以被输出. (别忘了, 默认都是开启冒泡)</p><p>但是. 如果使用 Safari 浏览器, 则会发现, 点击 parent, 输出:</p><ol><li>parent event capture</li><li>parent html</li><li>parent event</li><li>body</li><li>html</li><li>window</li></ol><p>点击 child, 输出:</p><ol><li>parent event capture</li><li>child event capture</li><li>child onclick</li><li>child event</li><li>parent html</li><li>parent event</li><li>body</li><li>html</li><li>window</li></ol><p>会发现, 对于捕获阶段的处理不一样了. 点击目标元素时, 目标元素不仅处于目标阶段, 也处于捕获阶段的终点和冒泡阶段的起点. 所以会进行 <code>capture</code> 的判断. 所以在代码编写时这里要尤为注意.</p><p><a href="https://www.jianshu.com/p/6512139d1d9e">原文地址</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>twoSum</title>
    <link href="/2017/05/07/algorithm/twoSum/"/>
    <url>/2017/05/07/algorithm/twoSum/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum/">LeetCode 第 1 题</a></p><p>[要求 Tc: O(n) Sc:O(n)]</p><p>按照题目要求, 我们第一时间想到的会是两层循环暴力解法：</p><h4 id="解法1-Time-O-n²-Space-O-1"><a href="#解法1-Time-O-n²-Space-O-1" class="headerlink" title="解法1: Time = O(n²), Space = O(1)"></a><strong>解法1: Time = O(n²), Space = O(1)</strong></h4><p>思路: 遍历每个元素 nums[j]，并查找是否存在一个值与 target - nums[j] 相等的目标元素。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">nums, target</span>) </span>&#123;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;             <span class="hljs-keyword">if</span> (nums[j] == target - nums[i]) &#123;                 <span class="hljs-keyword">return</span> [i,j];             &#125;         &#125;     &#125;     <span class="hljs-keyword">return</span> [];&#125;</code></pre><h4 id="解法2-Time-O-n-Space-O-n"><a href="#解法2-Time-O-n-Space-O-n" class="headerlink" title="解法2: Time = O(n), Space = O(n)"></a><strong>解法2: Time = O(n), Space = O(n)</strong></h4><p>我们可以通过哈希表空间换时间。在进行迭代并将元素插入到表中的同时，我们回过头来检查哈希表中是否已经存在当前元素所对应的目标元素，如果存在，那我们就找到了问题的解，将其返回即可.(时间复杂度为 O(n), 空间复杂度也为 O(n))</p><p>符合题目要求 bingo✌</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;    <span class="hljs-keyword">let</span> reduceHash = &#123;&#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;        <span class="hljs-keyword">let</span> reduceResult = target - nums[i];        <span class="hljs-keyword">if</span> (reduceHash[reduceResult] !== <span class="hljs-literal">undefined</span>) &#123;            <span class="hljs-keyword">return</span> [reduceHash[reduceResult], i];        &#125;        reduceHash[nums[i]] = i;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法与逻辑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AMD、CMD、CommonJS、ES6Module的区别</title>
    <link href="/2017/04/29/basic/AMD%E3%80%81CMD%E3%80%81CommonJS%E3%80%81ES6Module%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2017/04/29/basic/AMD%E3%80%81CMD%E3%80%81CommonJS%E3%80%81ES6Module%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>回想起之前的一次面试，第一轮面试官问我 AMD 和 CMD 的区别，我只回答说 AMD 是提前加载，CMD 是按需加载。第二轮面试官又问了我 CommonJS 和 ES6 Module 的区别，emmm…，我大致回答说新的比旧的好~~，虽然面试官并没有说什么，不过显然这样的答案并不是有助于面试、有助于自己的技术积累的。</p><p>所以有必要进行一次梳理，以便更清晰地了解它们的特点及差异。</p><a id="more"></a><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>AMD 一开始是 CommonJS 规范中的一个草案，全称是 Asynchronous Module Definition，即异步模块加载机制。后来由该草案的作者以 RequireJS 实现了 AMD 规范，所以一般说 AMD 也是指 RequireJS。</p><h4 id="RequireJS-的基本用法"><a href="#RequireJS-的基本用法" class="headerlink" title="RequireJS 的基本用法"></a>RequireJS 的基本用法</h4><p>通过<code>define</code>来定义一个模块，使用<code>require</code>可以导入定义的模块。</p><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><span class="hljs-comment">//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数</span>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;)<span class="hljs-comment">// b.js</span><span class="hljs-comment">//数组中声明需要加载的模块，可以是模块名、js文件路径</span><span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;a&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">// 1</span>&#125;);复制代码</code></pre><h4 id="RequireJS-的特点"><a href="#RequireJS-的特点" class="headerlink" title="RequireJS 的特点"></a>RequireJS 的特点</h4><p>对于依赖的模块，AMD 推崇<strong>依赖前置，提前执行</strong>。也就是说，在<code>define</code>方法里传入的依赖模块 (数组)，会在一开始就下载并执行。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD 是 SeaJS 在推广过程中生产的对模块定义的规范，在 Web 浏览器端的模块加载器中，SeaJS 与 RequireJS 并称，SeaJS 作者为阿里的玉伯。</p><h4 id="SeaJS-的基本用法"><a href="#SeaJS-的基本用法" class="headerlink" title="SeaJS 的基本用法"></a>SeaJS 的基本用法</h4><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><span class="hljs-comment">/*</span><span class="hljs-comment">* define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串，</span><span class="hljs-comment">* factory 为对象、字符串时，表示模块的接口就是该对象、字符串。</span><span class="hljs-comment">* define 也可以接受两个以上参数。字符串 id 表示模块标识，数组 deps 是模块依赖.</span><span class="hljs-comment">*/</span>define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require, exports, module</span>) </span>&#123;  <span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>);  <span class="hljs-built_in">exports</span>.setColor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    $(<span class="hljs-string">&#x27;body&#x27;</span>).css(<span class="hljs-string">&#x27;color&#x27;</span>,<span class="hljs-string">&#x27;#333&#x27;</span>);  &#125;;&#125;);<span class="hljs-comment">//b.js</span><span class="hljs-comment">//数组中声明需要加载的模块，可以是模块名、js文件路径</span>seajs.use([<span class="hljs-string">&#x27;a&#x27;</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;  $(<span class="hljs-string">&#x27;#el&#x27;</span>).click(a.setColor);&#125;);复制代码</code></pre><h4 id="SeaJS-的特点"><a href="#SeaJS-的特点" class="headerlink" title="SeaJS 的特点"></a>SeaJS 的特点</h4><p>对于依赖的模块，CMD 推崇<strong>依赖就近，延迟执行</strong>。也就是说，只有到<code>require</code>时依赖模块才执行。</p><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>CommonJS 规范为 CommonJS 小组所提出，目的是弥补 JavaScript 在服务器端缺少模块化机制，NodeJS、webpack 都是基于该规范来实现的。</p><h4 id="CommonJS-的基本用法"><a href="#CommonJS-的基本用法" class="headerlink" title="CommonJS 的基本用法"></a>CommonJS 的基本用法</h4><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello world&quot;</span>)&#125;<span class="hljs-comment">//b.js</span><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a&#x27;</span>);a();<span class="hljs-comment">//&quot;hello world&quot;</span><span class="hljs-comment">//或者</span><span class="hljs-comment">//a2.js</span><span class="hljs-built_in">exports</span>.num = <span class="hljs-number">1</span>;<span class="hljs-built_in">exports</span>.obj = &#123;<span class="hljs-attr">xx</span>: <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//b2.js</span><span class="hljs-keyword">var</span> a2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./a2&#x27;</span>);<span class="hljs-built_in">console</span>.log(a2);<span class="hljs-comment">//&#123; num: 1, obj: &#123; xx: 2 &#125; &#125;</span>复制代码</code></pre><h4 id="CommonJS-的特点"><a href="#CommonJS-的特点" class="headerlink" title="CommonJS 的特点"></a>CommonJS 的特点</h4><ul><li>所有代码都运行在模块作用域，不会污染全局作用域；</li><li>模块是同步加载的，即只有加载完成，才能执行后面的操作；</li><li>模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存；</li><li>CommonJS 输出是值的拷贝 (即，<code>require</code>返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值)。</li></ul><h3 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h3><p>ES6 Module 是 ES6 中规定的模块体系，相比上面提到的规范， ES6 Module 有更多的优势，有望成为浏览器和服务器通用的模块解决方案。</p><h4 id="ES6-Module-的基本用法"><a href="#ES6-Module-的基本用法" class="headerlink" title="ES6 Module 的基本用法"></a>ES6 Module 的基本用法</h4><pre><code class="hljs js"><span class="hljs-comment">//a.js</span><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;lin&#x27;</span>;<span class="hljs-keyword">var</span> age = <span class="hljs-number">13</span>;<span class="hljs-keyword">var</span> job = <span class="hljs-string">&#x27;ninja&#x27;</span>;<span class="hljs-keyword">export</span> &#123; name, age, job&#125;;<span class="hljs-comment">//b.js</span><span class="hljs-keyword">import</span> &#123; name, age, job&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a.js&#x27;</span>;<span class="hljs-built_in">console</span>.log(name, age, job);<span class="hljs-comment">// lin 13 ninja</span><span class="hljs-comment">//或者</span><span class="hljs-comment">//a2.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;default &#x27;</span>);&#125;<span class="hljs-comment">//b2.js</span><span class="hljs-keyword">import</span> customName <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a2.js&#x27;</span>;customName(); <span class="hljs-comment">// &#x27;default&#x27;</span>复制代码</code></pre><h4 id="ES6-Module-的特点-对比-CommonJS"><a href="#ES6-Module-的特点-对比-CommonJS" class="headerlink" title="ES6 Module 的特点 (对比 CommonJS)"></a>ES6 Module 的特点 (对比 CommonJS)</h4><ul><li>CommonJS 模块是运行时加载，ES6 Module 是编译时输出接口；</li><li>CommonJS 加载的是整个模块，将所有的接口全部加载进来，ES6 Module 可以单独加载其中的某个接口；</li><li>CommonJS 输出是值的拷贝，ES6 Module 输出的是值的引用，被输出模块的内部的改变会影响引用的改变；</li><li>CommonJS <code>this</code>指向当前模块，ES6 Module <code>this</code>指向<code>undefined</code>;</li></ul><p>目前浏览器对 ES6 Module 兼容还不太好，我们平时在 webpack 中使用的<code>export</code>/<code>import</code>，会被打包为<code>exports</code>/<code>require</code>。</p><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>这里比较宽泛地把 JavaScript 中的几大模块化规范列举出来，希望借此对 JavaScript 模块化有大致的认识，而未对细节展开具体分析，感兴趣的可以自行探索。</p><p>原文地址 <a href="https://juejin.im/post/5db95e3a6fb9a020704bcd8d">https://juejin.im/post/5db95e3a6fb9a020704bcd8d</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
